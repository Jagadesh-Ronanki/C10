{"ast":null,"code":"'use strict';\n\n/* global WebAssembly */\nconst assert = require('assert');\nconst net = require('net');\nconst util = require('./core/util');\nconst Request = require('./core/request');\nconst DispatcherBase = require('./dispatcher-base');\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError\n} = require('./core/errors');\nconst buildConnector = require('./core/connect');\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors\n} = require('./core/symbols');\nconst kClosedResolve = Symbol('kClosedResolve');\nconst channels = {};\ntry {\n  const diagnosticsChannel = require('diagnostics_channel');\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError');\n  channels.connected = diagnosticsChannel.channel('undici:client:connected');\n} catch {\n  channels.sendHeaders = {\n    hasSubscribers: false\n  };\n  channels.beforeConnect = {\n    hasSubscribers: false\n  };\n  channels.connectError = {\n    hasSubscribers: false\n  };\n  channels.connected = {\n    hasSubscribers: false\n  };\n}\nclass Client extends DispatcherBase {\n  constructor(url) {\n    let {\n      interceptors,\n      maxHeaderSize,\n      headersTimeout,\n      socketTimeout,\n      requestTimeout,\n      connectTimeout,\n      bodyTimeout,\n      idleTimeout,\n      keepAlive,\n      keepAliveTimeout,\n      maxKeepAliveTimeout,\n      keepAliveMaxTimeout,\n      keepAliveTimeoutThreshold,\n      socketPath,\n      pipelining,\n      tls,\n      strictContentLength,\n      maxCachedSessions,\n      maxRedirections,\n      connect,\n      maxRequestsPerClient\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');\n    }\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');\n    }\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');\n    }\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize');\n    }\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath');\n    }\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout');\n    }\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout');\n    }\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout');\n    }\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');\n    }\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');\n    }\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');\n    }\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');\n    }\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...connect\n      });\n    }\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({\n      maxRedirections\n    })];\n    this[kUrl] = util.parseOrigin(url);\n    this[kConnector] = connect;\n    this[kSocket] = null;\n    this[kPipelining] = pipelining != null ? pipelining : 1;\n    this[kMaxHeadersSize] = maxHeaderSize || 16384;\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n    this[kServerName] = null;\n    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`;\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3;\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3;\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n    this[kMaxRedirections] = maxRedirections;\n    this[kMaxRequests] = maxRequestsPerClient;\n    this[kClosedResolve] = null;\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = [];\n    this[kRunningIdx] = 0;\n    this[kPendingIdx] = 0;\n  }\n  get pipelining() {\n    return this[kPipelining];\n  }\n  set pipelining(value) {\n    this[kPipelining] = value;\n    resume(this, true);\n  }\n  get [kPending]() {\n    return this[kQueue].length - this[kPendingIdx];\n  }\n  get [kRunning]() {\n    return this[kPendingIdx] - this[kRunningIdx];\n  }\n  get [kSize]() {\n    return this[kQueue].length - this[kRunningIdx];\n  }\n  get [kConnected]() {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n  }\n  get [kBusy]() {\n    const socket = this[kSocket];\n    return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect](cb) {\n    connect(this);\n    this.once('connect', cb);\n  }\n  [kDispatch](opts, handler) {\n    const origin = opts.origin || this[kUrl].origin;\n    const request = new Request(origin, opts, handler);\n    this[kQueue].push(request);\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1;\n      process.nextTick(resume, this);\n    } else {\n      resume(this, true);\n    }\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2;\n    }\n    return this[kNeedDrain] < 2;\n  }\n  async [kClose]() {\n    return new Promise(resolve => {\n      if (!this[kSize]) {\n        this.destroy(resolve);\n      } else {\n        this[kClosedResolve] = resolve;\n      }\n    });\n  }\n  async [kDestroy](err) {\n    return new Promise(resolve => {\n      const requests = this[kQueue].splice(this[kPendingIdx]);\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i];\n        errorRequest(this, request, err);\n      }\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          this[kClosedResolve]();\n          this[kClosedResolve] = null;\n        }\n        resolve();\n      };\n      if (!this[kSocket]) {\n        queueMicrotask(callback);\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err);\n      }\n      resume(this);\n    });\n  }\n}\nconst constants = require('./llhttp/constants');\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor');\nconst EMPTY_BUF = Buffer.alloc(0);\nasync function lazyllhttp() {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp.wasm.js') : undefined;\n  let mod;\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'));\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp.wasm.js'), 'base64'));\n  }\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0;\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_message_begin: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageBegin() || 0;\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_message_complete: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageComplete() || 0;\n      }\n\n      /* eslint-enable camelcase */\n    }\n  });\n}\n\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp().catch(() => {});\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n  constructor(client, socket, _ref) {\n    let {\n      exports\n    } = _ref;\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n    this.llhttp = exports;\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n    this.client = client;\n    this.socket = socket;\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.statusCode = null;\n    this.statusText = '';\n    this.upgrade = false;\n    this.headers = [];\n    this.headersSize = 0;\n    this.headersMaxSize = client[kMaxHeadersSize];\n    this.shouldKeepAlive = false;\n    this.paused = false;\n    this.resume = this.resume.bind(this);\n    this.bytesRead = 0;\n    this.keepAlive = '';\n    this.contentLength = '';\n  }\n  setTimeout(value, type) {\n    this.timeoutType = type;\n    if (value !== this.timeoutValue) {\n      clearTimeout(this.timeout);\n      if (value) {\n        this.timeout = setTimeout(onParserTimeout, value, this);\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref();\n        }\n      } else {\n        this.timeout = null;\n      }\n      this.timeoutValue = value;\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n  }\n  resume() {\n    if (this.socket.destroyed || !this.paused) {\n      return;\n    }\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_resume(this.ptr);\n    assert(this.timeoutType === TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    this.paused = false;\n    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.\n    this.readMore();\n  }\n  readMore() {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read();\n      if (chunk === null) {\n        break;\n      }\n      this.execute(chunk);\n    }\n  }\n  execute(data) {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    assert(!this.paused);\n    const {\n      socket,\n      llhttp\n    } = this;\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr);\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n      currentBufferPtr = llhttp.malloc(currentBufferSize);\n    }\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret;\n      try {\n        currentBufferRef = data;\n        currentParser = this;\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err;\n      } finally {\n        currentParser = null;\n        currentBufferRef = null;\n      }\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset));\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true;\n        socket.unshift(data.slice(offset));\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n        let message = '';\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n  }\n  finish() {\n    try {\n      try {\n        currentParser = this;\n      } finally {\n        currentParser = null;\n      }\n    } catch (err) {\n      /* istanbul ignore next: difficult to make a test case for */\n      util.destroy(this.socket, err);\n    }\n  }\n  destroy() {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_free(this.ptr);\n    this.ptr = null;\n    clearTimeout(this.timeout);\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.paused = false;\n  }\n  onStatus(buf) {\n    this.statusText = buf.toString();\n  }\n  onMessageBegin() {\n    const {\n      socket,\n      client\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    if (!request) {\n      return -1;\n    }\n  }\n  onHeaderField(buf) {\n    const len = this.headers.length;\n    if ((len & 1) === 0) {\n      this.headers.push(buf);\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    this.trackHeader(buf.length);\n  }\n  onHeaderValue(buf) {\n    let len = this.headers.length;\n    if ((len & 1) === 1) {\n      this.headers.push(buf);\n      len += 1;\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    const key = this.headers[len - 2];\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString();\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString();\n    }\n    this.trackHeader(buf.length);\n  }\n  trackHeader(len) {\n    this.headersSize += len;\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError());\n    }\n  }\n  onUpgrade(head) {\n    const {\n      upgrade,\n      client,\n      socket,\n      headers,\n      statusCode\n    } = this;\n    assert(upgrade);\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(!socket.destroyed);\n    assert(socket === client[kSocket]);\n    assert(!this.paused);\n    assert(request.upgrade || request.method === 'CONNECT');\n    this.statusCode = null;\n    this.statusText = '';\n    this.shouldKeepAlive = null;\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    socket.unshift(head);\n    socket[kParser].destroy();\n    socket[kParser] = null;\n    socket[kClient] = null;\n    socket[kError] = null;\n    socket.removeListener('error', onSocketError).removeListener('readable', onSocketReadable).removeListener('end', onSocketEnd).removeListener('close', onSocketClose);\n    client[kSocket] = null;\n    client[kQueue][client[kRunningIdx]++] = null;\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));\n    try {\n      request.onUpgrade(statusCode, headers, socket);\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n    resume(client);\n  }\n  onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n    const {\n      client,\n      socket,\n      headers,\n      statusText\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1;\n    }\n    assert(!this.upgrade);\n    assert(this.statusCode < 200);\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));\n      return -1;\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));\n      return -1;\n    }\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n    this.statusCode = statusCode;\n    this.shouldKeepAlive = shouldKeepAlive;\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    if (upgrade) {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n        if (timeout <= 0) {\n          socket[kReset] = true;\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout;\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true;\n    }\n    let pause;\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n    if (request.method === 'HEAD') {\n      assert(socket[kReset]);\n      return 1;\n    }\n    if (statusCode < 200) {\n      return 1;\n    }\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false;\n      resume(client);\n    }\n    return pause ? constants.ERROR.PAUSED : 0;\n  }\n  onBody(buf) {\n    const {\n      client,\n      socket,\n      statusCode\n    } = this;\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    assert(statusCode >= 200);\n    this.bytesRead += buf.length;\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED;\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n  }\n  onMessageComplete() {\n    const {\n      client,\n      socket,\n      statusCode,\n      upgrade,\n      headers,\n      contentLength,\n      bytesRead,\n      shouldKeepAlive\n    } = this;\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1;\n    }\n    if (upgrade) {\n      return;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(statusCode >= 100);\n    this.statusCode = null;\n    this.statusText = '';\n    this.bytesRead = 0;\n    this.contentLength = '';\n    this.keepAlive = '';\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (statusCode < 200) {\n      return;\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError());\n      return -1;\n    }\n    try {\n      request.onComplete(headers);\n    } catch (err) {\n      errorRequest(client, request, err);\n    }\n    client[kQueue][client[kRunningIdx]++] = null;\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0);\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client);\n    } else {\n      resume(client);\n    }\n  }\n}\nfunction onParserTimeout(parser) {\n  const {\n    socket,\n    timeoutType,\n    client\n  } = parser;\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers');\n      util.destroy(socket, new HeadersTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n    util.destroy(socket, new InformationalError('socket idle timeout'));\n  }\n}\nfunction onSocketReadable() {\n  const {\n    [kParser]: parser\n  } = this;\n  parser.readMore();\n}\nfunction onSocketError(err) {\n  const {\n    [kParser]: parser\n  } = this;\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.finish();\n    return;\n  }\n  this[kError] = err;\n  onError(this[kClient], err);\n}\nfunction onError(client, err) {\n  if (client[kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx]);\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n    assert(client[kSize] === 0);\n  }\n}\nfunction onSocketEnd() {\n  const {\n    [kParser]: parser\n  } = this;\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.finish();\n    return;\n  }\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n}\nfunction onSocketClose() {\n  const {\n    [kClient]: client\n  } = this;\n  this[kParser].destroy();\n  this[kParser] = null;\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n  client[kSocket] = null;\n  if (client.destroyed) {\n    assert(client[kPending] === 0);\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]];\n    client[kQueue][client[kRunningIdx]++] = null;\n    errorRequest(client, request, err);\n  }\n  client[kPendingIdx] = client[kRunningIdx];\n  assert(client[kRunning] === 0);\n  client.emit('disconnect', client[kUrl], [client], err);\n  resume(client);\n}\nasync function connect(client) {\n  assert(!client[kConnecting]);\n  assert(!client[kSocket]);\n  let {\n    host,\n    hostname,\n    protocol,\n    port\n  } = client[kUrl];\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']');\n    assert(idx !== -1);\n    const ip = hostname.substr(1, idx - 1);\n    assert(net.isIP(ip));\n    hostname = ip;\n  }\n  client[kConnecting] = true;\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      },\n      connector: client[kConnector]\n    });\n  }\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      }, (err, socket) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(socket);\n        }\n      });\n    });\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise;\n      llhttpPromise = null;\n    }\n    client[kConnecting] = false;\n    assert(socket);\n    client[kSocket] = socket;\n    socket[kNoRef] = false;\n    socket[kWriting] = false;\n    socket[kReset] = false;\n    socket[kBlocking] = false;\n    socket[kError] = null;\n    socket[kParser] = new Parser(client, socket, llhttpInstance);\n    socket[kClient] = client;\n    socket[kCounter] = 0;\n    socket[kMaxRequests] = client[kMaxRequests];\n    socket.on('error', onSocketError).on('readable', onSocketReadable).on('end', onSocketEnd).on('close', onSocketClose);\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        socket\n      });\n    }\n    client.emit('connect', client[kUrl], [client]);\n  } catch (err) {\n    client[kConnecting] = false;\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        error: err\n      });\n    }\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0);\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++];\n        errorRequest(client, request, err);\n      }\n    } else {\n      onError(client, err);\n    }\n    client.emit('connectionError', client[kUrl], [client], err);\n  }\n  resume(client);\n}\nfunction emitDrain(client) {\n  client[kNeedDrain] = 0;\n  client.emit('drain', client[kUrl], [client]);\n}\nfunction resume(client, sync) {\n  if (client[kResuming] === 2) {\n    return;\n  }\n  client[kResuming] = 2;\n  _resume(client, sync);\n  client[kResuming] = 0;\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx]);\n    client[kPendingIdx] -= client[kRunningIdx];\n    client[kRunningIdx] = 0;\n  }\n}\nfunction _resume(client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0);\n      return;\n    }\n    if (client.closed && !client[kSize]) {\n      client.destroy();\n      return;\n    }\n    const socket = client[kSocket];\n    if (socket) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref();\n          socket[kNoRef] = true;\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref();\n        socket[kNoRef] = false;\n      }\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]];\n          const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n        }\n      }\n    }\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2;\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1;\n        process.nextTick(emitDrain, client);\n      } else {\n        emitDrain(client);\n      }\n      continue;\n    }\n    if (client[kPending] === 0) {\n      return;\n    }\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return;\n    }\n    const request = client[kQueue][client[kPendingIdx]];\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return;\n      }\n      client[kServerName] = request.servername;\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'));\n        return;\n      }\n    }\n    if (client[kConnecting]) {\n      return;\n    }\n    if (!socket) {\n      connect(client);\n      continue;\n    }\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return;\n    }\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return;\n    }\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body.on('data', /* istanbul ignore next */function () {\n        /* istanbul ignore next */\n        assert(false);\n      }).on('error', function (err) {\n        errorRequest(client, request, err);\n      }).on('end', function () {\n        util.destroy(this);\n      });\n      request.body = null;\n    }\n    if (client[kRunning] > 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++;\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1);\n    }\n  }\n}\nfunction write(client, request) {\n  const {\n    body,\n    method,\n    path,\n    host,\n    upgrade,\n    headers,\n    blocking\n  } = request;\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0);\n  }\n  let contentLength = util.bodyLength(body);\n  if (contentLength === null) {\n    contentLength = request.contentLength;\n  }\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null;\n  }\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError());\n      return false;\n    }\n    process.emitWarning(new RequestContentLengthMismatchError());\n  }\n  const socket = client[kSocket];\n  try {\n    request.onConnect(err => {\n      if (request.aborted || request.completed) {\n        return;\n      }\n      errorRequest(client, request, err || new RequestAbortedError());\n      util.destroy(socket, new InformationalError('aborted'));\n    });\n  } catch (err) {\n    errorRequest(client, request, err);\n  }\n  if (request.aborted) {\n    return false;\n  }\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true;\n  }\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true;\n  }\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true;\n  }\n  if (blocking) {\n    socket[kBlocking] = true;\n  }\n  let header = `${method} ${path} HTTP/1.1\\r\\n`;\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`;\n  } else {\n    header += client[kHostHeader];\n  }\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n  } else if (client[kPipelining]) {\n    header += 'connection: keep-alive\\r\\n';\n  } else {\n    header += 'connection: close\\r\\n';\n  }\n  if (headers) {\n    header += headers;\n  }\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({\n      request,\n      headers: header,\n      socket\n    });\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii');\n    } else {\n      assert(contentLength === null, 'no body must not have content length');\n      socket.write(`${header}\\r\\n`, 'ascii');\n    }\n    request.onRequestSent();\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length');\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n    socket.write(body);\n    socket.uncork();\n    request.onBodySent(body);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({\n        body: body.stream(),\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    } else {\n      writeBlob({\n        body,\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    }\n  } else if (util.isStream(body)) {\n    writeStream({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else if (util.isIterable(body)) {\n    writeIterable({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else {\n    assert(false);\n  }\n  return true;\n}\nfunction writeStream(_ref2) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref2;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n  let finished = false;\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  const onData = function (chunk) {\n    try {\n      assert(!finished);\n      if (!writer.write(chunk) && this.pause) {\n        this.pause();\n      }\n    } catch (err) {\n      util.destroy(this, err);\n    }\n  };\n  const onDrain = function () {\n    assert(!finished);\n    if (body.resume) {\n      body.resume();\n    }\n  };\n  const onAbort = function () {\n    onFinished(new RequestAbortedError());\n  };\n  const onFinished = function (err) {\n    if (finished) {\n      return;\n    }\n    finished = true;\n    assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n    socket.off('drain', onDrain).off('error', onFinished);\n    body.removeListener('data', onData).removeListener('end', onFinished).removeListener('error', onFinished).removeListener('close', onAbort);\n    if (!err) {\n      try {\n        writer.end();\n      } catch (er) {\n        err = er;\n      }\n    }\n    writer.destroy(err);\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err);\n    } else {\n      util.destroy(body);\n    }\n  };\n  body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);\n  if (body.resume) {\n    body.resume();\n  }\n  socket.on('drain', onDrain).on('error', onFinished);\n}\nasync function writeBlob(_ref3) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref3;\n  assert(contentLength === body.size, 'blob body must have content length');\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError();\n    }\n    const buffer = Buffer.from(await body.arrayBuffer());\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n    socket.write(buffer);\n    socket.uncork();\n    request.onBodySent(buffer);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n    resume(client);\n  } catch (err) {\n    util.destroy(socket, err);\n  }\n}\nasync function writeIterable(_ref4) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref4;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n  let callback = null;\n  function onDrain() {\n    if (callback) {\n      const cb = callback;\n      callback = null;\n      cb();\n    }\n  }\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null);\n    if (socket[kError]) {\n      reject(socket[kError]);\n    } else {\n      callback = resolve;\n    }\n  });\n  socket.on('close', onDrain).on('drain', onDrain);\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError];\n      }\n      if (!writer.write(chunk)) {\n        await waitForDrain();\n      }\n    }\n    writer.end();\n  } catch (err) {\n    writer.destroy(err);\n  } finally {\n    socket.off('close', onDrain).off('drain', onDrain);\n  }\n}\nclass AsyncWriter {\n  constructor(_ref5) {\n    let {\n      socket,\n      request,\n      contentLength,\n      client,\n      expectsPayload,\n      header\n    } = _ref5;\n    this.socket = socket;\n    this.request = request;\n    this.contentLength = contentLength;\n    this.client = client;\n    this.bytesWritten = 0;\n    this.expectsPayload = expectsPayload;\n    this.header = header;\n    socket[kWriting] = true;\n  }\n  write(chunk) {\n    const {\n      socket,\n      request,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header\n    } = this;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return false;\n    }\n    const len = Buffer.byteLength(chunk);\n    if (!len) {\n      return true;\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      }\n      process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true;\n      }\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii');\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n      }\n    }\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii');\n    }\n    this.bytesWritten += len;\n    const ret = socket.write(chunk);\n    request.onBodySent(chunk);\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh();\n        }\n      }\n    }\n    return ret;\n  }\n  end() {\n    const {\n      socket,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header,\n      request\n    } = this;\n    request.onRequestSent();\n    socket[kWriting] = false;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return;\n    }\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii');\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii');\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii');\n    }\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError());\n      }\n    }\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh();\n      }\n    }\n    resume(client);\n  }\n  destroy(err) {\n    const {\n      socket,\n      client\n    } = this;\n    socket[kWriting] = false;\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request');\n      util.destroy(socket, err);\n    }\n  }\n}\nfunction errorRequest(client, request, err) {\n  try {\n    request.onError(err);\n    assert(request.aborted);\n  } catch (err) {\n    client.emit('error', err);\n  }\n}\nmodule.exports = Client;","map":{"version":3,"names":["assert","require","net","util","Request","DispatcherBase","RequestContentLengthMismatchError","ResponseContentLengthMismatchError","InvalidArgumentError","RequestAbortedError","HeadersTimeoutError","HeadersOverflowError","SocketError","InformationalError","BodyTimeoutError","HTTPParserError","buildConnector","kUrl","kReset","kServerName","kClient","kBusy","kParser","kConnect","kBlocking","kResuming","kRunning","kPending","kSize","kWriting","kQueue","kConnected","kConnecting","kNeedDrain","kNoRef","kKeepAliveDefaultTimeout","kHostHeader","kPendingIdx","kRunningIdx","kError","kPipelining","kSocket","kKeepAliveTimeoutValue","kMaxHeadersSize","kKeepAliveMaxTimeout","kKeepAliveTimeoutThreshold","kHeadersTimeout","kBodyTimeout","kStrictContentLength","kConnector","kMaxRedirections","kMaxRequests","kCounter","kClose","kDestroy","kDispatch","kInterceptors","kClosedResolve","Symbol","channels","diagnosticsChannel","sendHeaders","channel","beforeConnect","connectError","connected","hasSubscribers","Client","constructor","url","interceptors","maxHeaderSize","headersTimeout","socketTimeout","requestTimeout","connectTimeout","bodyTimeout","idleTimeout","keepAlive","keepAliveTimeout","maxKeepAliveTimeout","keepAliveMaxTimeout","keepAliveTimeoutThreshold","socketPath","pipelining","tls","strictContentLength","maxCachedSessions","maxRedirections","connect","maxRequestsPerClient","undefined","Number","isFinite","isInteger","timeout","Array","isArray","createRedirectInterceptor","parseOrigin","hostname","port","value","resume","length","destroyed","socket","cb","once","opts","handler","origin","request","push","bodyLength","body","isIterable","process","nextTick","Promise","resolve","destroy","err","requests","splice","i","errorRequest","callback","queueMicrotask","on","constants","EMPTY_BUF","Buffer","alloc","lazyllhttp","llhttpWasmData","env","JEST_WORKER_ID","mod","WebAssembly","compile","from","e","instantiate","wasm_on_url","p","at","len","wasm_on_status","strictEqual","currentParser","ptr","start","currentBufferPtr","end","onStatus","currentBufferRef","slice","wasm_on_message_begin","onMessageBegin","wasm_on_header_field","onHeaderField","wasm_on_header_value","onHeaderValue","wasm_on_headers_complete","statusCode","upgrade","shouldKeepAlive","onHeadersComplete","Boolean","wasm_on_body","onBody","wasm_on_message_complete","onMessageComplete","llhttpInstance","llhttpPromise","catch","currentBufferSize","TIMEOUT_HEADERS","TIMEOUT_BODY","TIMEOUT_IDLE","Parser","client","exports","llhttp","llhttp_alloc","TYPE","RESPONSE","timeoutValue","timeoutType","statusText","headers","headersSize","headersMaxSize","paused","bind","bytesRead","contentLength","setTimeout","type","clearTimeout","onParserTimeout","unref","refresh","llhttp_resume","execute","read","readMore","chunk","data","free","Math","ceil","malloc","Uint8Array","memory","buffer","set","ret","llhttp_execute","offset","llhttp_get_error_pos","ERROR","PAUSED_UPGRADE","onUpgrade","PAUSED","unshift","OK","llhttp_get_error_reason","message","indexOf","toString","finish","llhttp_free","buf","concat","trackHeader","key","toLowerCase","head","method","removeListener","onSocketError","onSocketReadable","onSocketEnd","onSocketClose","emit","getSocketInfo","parseKeepAliveTimeout","min","pause","onHeaders","onData","parseInt","onComplete","setImmediate","parser","writableNeedDrain","code","onError","host","protocol","idx","ip","substr","isIP","publish","connectParams","servername","connector","reject","error","emitDrain","sync","_resume","closed","ref","idempotent","isStream","isAsyncIterable","aborted","write","path","blocking","expectsPayload","emitWarning","onConnect","completed","header","onRequestSent","isBuffer","byteLength","cork","uncork","onBodySent","isBlobLike","stream","writeIterable","writeBlob","writeStream","finished","writer","AsyncWriter","onDrain","onAbort","onFinished","off","er","size","arrayBuffer","waitForDrain","bytesWritten","module"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/undici/lib/client.js"],"sourcesContent":["'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('assert')\nconst net = require('net')\nconst util = require('./core/util')\nconst Request = require('./core/request')\nconst DispatcherBase = require('./dispatcher-base')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError\n} = require('./core/errors')\nconst buildConnector = require('./core/connect')\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors\n} = require('./core/symbols')\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\nclass Client extends DispatcherBase {\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)\n      ? interceptors.Client\n      : [createRedirectInterceptor({ maxRedirections })]\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || 16384\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n\n    const request = new Request(origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      process.nextTick(resume, this)\n    } else {\n      resume(this, true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    return new Promise((resolve) => {\n      if (!this[kSize]) {\n        this.destroy(resolve)\n      } else {\n        this[kClosedResolve] = resolve\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve()\n      }\n\n      if (!this[kSocket]) {\n        queueMicrotask(callback)\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err)\n      }\n\n      resume(this)\n    })\n  }\n}\n\nconst constants = require('./llhttp/constants')\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor')\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp.wasm.js') : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp.wasm.js'), 'base64'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\n  .catch(() => {\n  })\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString()\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  finish () {\n    try {\n      try {\n        currentParser = this\n      } finally {\n        currentParser = null\n      }\n    } catch (err) {\n      /* istanbul ignore next: difficult to make a test case for */\n      util.destroy(this.socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = shouldKeepAlive\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    let pause\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      assert(socket[kReset])\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    this.bytesRead += buf.length\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    try {\n      request.onComplete(headers)\n    } catch (err) {\n      errorRequest(client, request, err)\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client)\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  parser.readMore()\n}\n\nfunction onSocketError (err) {\n  const { [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.finish()\n    return\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser } = this\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.finish()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client } = this\n\n  this[kParser].destroy()\n  this[kParser] = null\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substr(1, idx - 1)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise\n      llhttpPromise = null\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    client[kSocket] = socket\n\n    socket[kNoRef] = false\n    socket[kWriting] = false\n    socket[kReset] = false\n    socket[kBlocking] = false\n    socket[kError] = null\n    socket[kParser] = new Parser(client, socket, llhttpInstance)\n    socket[kClient] = client\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client.closed && !client[kSize]) {\n      client.destroy()\n      return\n    }\n\n    const socket = client[kSocket]\n\n    if (socket) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket) {\n      connect(client)\n      continue\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body\n        .on('data', /* istanbul ignore next */ function () {\n          /* istanbul ignore next */\n          assert(false)\n        })\n        .on('error', function (err) {\n          errorRequest(client, request, err)\n        })\n        .on('end', function () {\n          util.destroy(this)\n        })\n\n      request.body = null\n    }\n\n    if (client[kRunning] > 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nfunction write (client, request) {\n  const { body, method, path, host, upgrade, headers, blocking } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'ascii')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    try {\n      assert(!finished)\n\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    assert(!finished)\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    onFinished(new RequestAbortedError())\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(socket, err)\n  }\n}\n\nasync function writeIterable ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}