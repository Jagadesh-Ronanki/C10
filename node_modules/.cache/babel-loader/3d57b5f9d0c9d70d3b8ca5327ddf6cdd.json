{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProvider = void 0;\nconst events_1 = require(\"events\");\nconst constants_1 = require(\"../../constants\");\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\nconst packageInfo_1 = require(\"../../util/packageInfo\");\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst errors_2 = require(\"./errors\");\nfunction isErrorResponse(response) {\n  return typeof response.error !== \"undefined\";\n}\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\nconst TOO_MANY_REQUEST_STATUS = 429;\nconst hardhatVersion = (0, packageInfo_1.getHardhatVersion)();\nclass HttpProvider extends events_1.EventEmitter {\n  constructor(_url, _networkName) {\n    let _extraHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let _timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20000;\n    let client = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    super();\n    this._url = _url;\n    this._networkName = _networkName;\n    this._extraHeaders = _extraHeaders;\n    this._timeout = _timeout;\n    this._nextRequestId = 1;\n    const {\n      Pool\n    } = require(\"undici\");\n    const url = new URL(this._url);\n    this._path = url.pathname;\n    this._authHeader = url.username === \"\" ? undefined : `Basic ${Buffer.from(`${url.username}:${url.password}`, \"utf-8\").toString(\"base64\")}`;\n    try {\n      this._dispatcher = client ?? new Pool(url.origin);\n    } catch (e) {\n      if (e instanceof TypeError && e.message === \"Invalid URL\") {\n        e.message += ` ${url.origin}`;\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n  get url() {\n    return this._url;\n  }\n  async request(args) {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1);\n    const jsonRpcRequest = this._getJsonRpcRequest(args.method, args.params);\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data;\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n    if (args.method === \"hardhat_reset\") {\n      this.emit(constants_1.HARDHAT_NETWORK_RESET_EVENT);\n    }\n    if (args.method === \"evm_revert\") {\n      this.emit(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n    return jsonRpcResponse.result;\n  }\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n  async sendBatch(batch) {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1);\n    // we need this to sort the responses\n    const idToIndexMap = {};\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data;\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    }\n    // We already know that it has this type, but TS can't infer it.\n    const responses = jsonRpcResponses;\n    // we use the id to sort the responses so that they match the order of the requests\n    const sortedResponses = responses.map(response => [idToIndexMap[response.id], response.result]).sort((_ref, _ref2) => {\n      let [indexA] = _ref;\n      let [indexB] = _ref2;\n      return indexA - indexB;\n    }).map(_ref3 => {\n      let [, result] = _ref3;\n      return result;\n    });\n    return sortedResponses;\n  }\n  async _fetchJsonRpcResponse(request) {\n    let retryNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    try {\n      const response = await this._dispatcher.request({\n        method: \"POST\",\n        path: this._path,\n        body: JSON.stringify(request),\n        maxRedirections: 10,\n        headersTimeout: process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined ? 0 : this._timeout,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"User-Agent\": `hardhat ${hardhatVersion ?? \"(unknown version)\"}`,\n          Authorization: this._authHeader,\n          ...this._extraHeaders\n        }\n      });\n      if (this._isRateLimitResponse(response)) {\n        // \"The Fetch Standard allows users to skip consuming the response body\n        // by relying on garbage collection to release connection resources.\n        // Undici does not do the same. Therefore, it is important to always\n        // either consume or cancel the response body.\"\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        // It's not clear how to \"cancel\", so we'll just consume:\n        await response.body.text();\n        const seconds = this._getRetryAfterSeconds(response);\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n        const url = new URL(this._url);\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new errors_2.ProviderError(`Too Many Requests error received from ${url.hostname}`, -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return (0, jsonrpc_1.parseJsonResponse)(await response.body.text());\n    } catch (error) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NODE_IS_NOT_RUNNING, {\n          network: this._networkName\n        }, error);\n      }\n      if (error.type === \"request-timeout\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n  async _retry(request, seconds, retryNumber) {\n    await new Promise(resolve => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n  _getJsonRpcRequest(method) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++\n    };\n  }\n  _shouldRetry(retryNumber, retryAfterSeconds) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n    return true;\n  }\n  _isRateLimitResponse(response) {\n    return response.statusCode === TOO_MANY_REQUEST_STATUS;\n  }\n  _getRetryAfterSeconds(response) {\n    const header = response.headers[\"retry-after\"];\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n    const parsed = parseInt(header, 10);\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n    return parsed;\n  }\n}\nexports.HttpProvider = HttpProvider;","map":{"version":3,"mappings":"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","names":["isErrorResponse","response","error","MAX_RETRIES","MAX_RETRY_AWAIT_SECONDS","TOO_MANY_REQUEST_STATUS","hardhatVersion","HttpProvider","events_1","constructor","_url","_networkName","_extraHeaders","_timeout","client","undefined","Pool","require","url","URL","_path","pathname","_authHeader","username","Buffer","from","password","toString","_dispatcher","origin","e","TypeError","message","request","args","errors_2","jsonRpcRequest","_getJsonRpcRequest","method","params","jsonRpcResponse","_fetchJsonRpcResponse","code","data","emit","constants_1","result","sendBatch","batch","idToIndexMap","requests","map","r","i","id","jsonRpcResponses","responses","sortedResponses","sort","indexA","indexB","retryNumber","path","body","JSON","stringify","maxRedirections","headersTimeout","process","env","DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI","headers","Authorization","_isRateLimitResponse","text","seconds","_getRetryAfterSeconds","_shouldRetry","_retry","hostname","errors_1","errors_list_1","NETWORK","NODE_IS_NOT_RUNNING","network","type","NETWORK_TIMEOUT","Promise","resolve","setTimeout","jsonrpc","_nextRequestId","retryAfterSeconds","statusCode","header","parsed","parseInt","isNaN","exports"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/hardhat/src/internal/core/providers/http.ts"],"sourcesContent":["import type { Dispatcher, Pool as PoolT } from \"undici\";\n\nimport { EventEmitter } from \"events\";\n\nimport { EIP1193Provider, RequestArguments } from \"../../../types\";\nimport {\n  HARDHAT_NETWORK_RESET_EVENT,\n  HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT,\n} from \"../../constants\";\nimport {\n  FailedJsonRpcResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  parseJsonResponse,\n  SuccessfulJsonRpcResponse,\n} from \"../../util/jsonrpc\";\nimport { getHardhatVersion } from \"../../util/packageInfo\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\nimport { ProviderError } from \"./errors\";\n\nfunction isErrorResponse(response: any): response is FailedJsonRpcResponse {\n  return typeof response.error !== \"undefined\";\n}\n\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\n\nconst TOO_MANY_REQUEST_STATUS = 429;\n\nconst hardhatVersion = getHardhatVersion();\n\nexport class HttpProvider extends EventEmitter implements EIP1193Provider {\n  private _nextRequestId = 1;\n  private _dispatcher: Dispatcher;\n  private _path: string;\n  private _authHeader: string | undefined;\n\n  constructor(\n    private readonly _url: string,\n    private readonly _networkName: string,\n    private readonly _extraHeaders: { [name: string]: string } = {},\n    private readonly _timeout = 20000,\n    client: Dispatcher | undefined = undefined\n  ) {\n    super();\n\n    const { Pool } = require(\"undici\") as { Pool: typeof PoolT };\n\n    const url = new URL(this._url);\n    this._path = url.pathname;\n    this._authHeader =\n      url.username === \"\"\n        ? undefined\n        : `Basic ${Buffer.from(\n            `${url.username}:${url.password}`,\n            \"utf-8\"\n          ).toString(\"base64\")}`;\n    try {\n      this._dispatcher = client ?? new Pool(url.origin);\n    } catch (e) {\n      if (e instanceof TypeError && e.message === \"Invalid URL\") {\n        e.message += ` ${url.origin}`;\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  public get url(): string {\n    return this._url;\n  }\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new ProviderError(\"HttpProviderError\", -1);\n\n    const jsonRpcRequest = this._getJsonRpcRequest(\n      args.method,\n      args.params as any[]\n    );\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data;\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(HARDHAT_NETWORK_RESET_EVENT);\n    }\n    if (args.method === \"evm_revert\") {\n      this.emit(HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    return jsonRpcResponse.result;\n  }\n\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n  public async sendBatch(\n    batch: Array<{ method: string; params: any[] }>\n  ): Promise<any[]> {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new ProviderError(\"HttpProviderError\", -1);\n\n    // we need this to sort the responses\n    const idToIndexMap: Record<string, number> = {};\n\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data;\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    }\n\n    // We already know that it has this type, but TS can't infer it.\n    const responses = jsonRpcResponses as SuccessfulJsonRpcResponse[];\n\n    // we use the id to sort the responses so that they match the order of the requests\n    const sortedResponses = responses\n      .map(\n        (response) =>\n          [idToIndexMap[response.id], response.result] as [number, any]\n      )\n      .sort(([indexA], [indexB]) => indexA - indexB)\n      .map(([, result]) => result);\n\n    return sortedResponses;\n  }\n\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest,\n    retryNumber?: number\n  ): Promise<JsonRpcResponse>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber = 0\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]> {\n    try {\n      const response = await this._dispatcher.request({\n        method: \"POST\",\n        path: this._path,\n        body: JSON.stringify(request),\n        maxRedirections: 10,\n        headersTimeout:\n          process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined\n            ? 0\n            : this._timeout,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"User-Agent\": `hardhat ${hardhatVersion ?? \"(unknown version)\"}`,\n          Authorization: this._authHeader,\n          ...this._extraHeaders,\n        },\n      });\n\n      if (this._isRateLimitResponse(response)) {\n        // \"The Fetch Standard allows users to skip consuming the response body\n        // by relying on garbage collection to release connection resources.\n        // Undici does not do the same. Therefore, it is important to always\n        // either consume or cancel the response body.\"\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        // It's not clear how to \"cancel\", so we'll just consume:\n        await response.body.text();\n        const seconds = this._getRetryAfterSeconds(response);\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n\n        const url = new URL(this._url);\n\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new ProviderError(\n          `Too Many Requests error received from ${url.hostname}`,\n          -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return parseJsonResponse(await response.body.text());\n    } catch (error: any) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new HardhatError(\n          ERRORS.NETWORK.NODE_IS_NOT_RUNNING,\n          { network: this._networkName },\n          error\n        );\n      }\n\n      if (error.type === \"request-timeout\") {\n        throw new HardhatError(ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  private async _retry(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    seconds: number,\n    retryNumber: number\n  ) {\n    await new Promise((resolve) => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n\n  private _getJsonRpcRequest(\n    method: string,\n    params: any[] = []\n  ): JsonRpcRequest {\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++,\n    };\n  }\n\n  private _shouldRetry(retryNumber: number, retryAfterSeconds: number) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private _isRateLimitResponse(response: Dispatcher.ResponseData) {\n    return response.statusCode === TOO_MANY_REQUEST_STATUS;\n  }\n\n  private _getRetryAfterSeconds(\n    response: Dispatcher.ResponseData\n  ): number | undefined {\n    const header = response.headers[\"retry-after\"];\n\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n\n    const parsed = parseInt(header, 10);\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n\n    return parsed;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}