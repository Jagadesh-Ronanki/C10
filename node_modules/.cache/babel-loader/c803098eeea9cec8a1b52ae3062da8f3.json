{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getArtifactFromContractOutput = exports.Artifacts = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst promises_1 = __importDefault(require(\"fs/promises\"));\nconst contract_names_1 = require(\"../utils/contract-names\");\nconst source_names_1 = require(\"../utils/source-names\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./core/errors\");\nconst errors_list_1 = require(\"./core/errors-list\");\nconst hash_1 = require(\"./util/hash\");\nconst fs_utils_1 = require(\"./util/fs-utils\");\nconst log = (0, debug_1.default)(\"hardhat:core:artifacts\");\nclass Artifacts {\n  constructor(_artifactsPath) {\n    this._artifactsPath = _artifactsPath;\n    // Undefined means that the cache is disabled.\n    this._cache = {\n      artifactNameToArtifactPathCache: new Map(),\n      artifactFQNToBuildInfoPathCache: new Map()\n    };\n    this._validArtifacts = [];\n  }\n  addValidArtifacts(validArtifacts) {\n    this._validArtifacts.push(...validArtifacts);\n  }\n  async readArtifact(name) {\n    const artifactPath = await this._getArtifactPath(name);\n    return fs_extra_1.default.readJson(artifactPath);\n  }\n  readArtifactSync(name) {\n    const artifactPath = this._getArtifactPathSync(name);\n    return fs_extra_1.default.readJsonSync(artifactPath);\n  }\n  async artifactExists(name) {\n    const artifactPath = await this._getArtifactPath(name);\n    return fs_extra_1.default.pathExists(artifactPath);\n  }\n  async getAllFullyQualifiedNames() {\n    const paths = await this.getArtifactPaths();\n    return paths.map(p => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n  async getBuildInfo(fullyQualifiedName) {\n    let buildInfoPath = this._cache?.artifactFQNToBuildInfoPathCache.get(fullyQualifiedName);\n    if (buildInfoPath === undefined) {\n      const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n      const debugFilePath = this._getDebugFilePath(artifactPath);\n      buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n      if (buildInfoPath === undefined) {\n        return undefined;\n      }\n      this._cache?.artifactFQNToBuildInfoPathCache.set(fullyQualifiedName, buildInfoPath);\n    }\n    return fs_extra_1.default.readJSON(buildInfoPath);\n  }\n  async getArtifactPaths() {\n    const cached = this._cache?.artifactPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n    const buildInfosDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n    const paths = await (0, fs_utils_1.getAllFilesMatching)(this._artifactsPath, f => f.endsWith(\".json\") && !f.startsWith(buildInfosDir) && !f.endsWith(\".dbg.json\"));\n    const result = paths.sort();\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n    return result;\n  }\n  async getBuildInfoPaths() {\n    const cached = this._cache?.buildInfoPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n    const paths = await (0, fs_utils_1.getAllFilesMatching)(path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME), f => f.endsWith(\".json\"));\n    const result = paths.sort();\n    if (this._cache !== undefined) {\n      this._cache.buildInfoPaths = result;\n    }\n    return result;\n  }\n  async getDebugFilePaths() {\n    const cached = this._cache?.debugFilePaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n    const paths = await (0, fs_utils_1.getAllFilesMatching)(path.join(this._artifactsPath), f => f.endsWith(\".dbg.json\"));\n    const result = paths.sort();\n    if (this._cache !== undefined) {\n      this._cache.debugFilePaths = result;\n    }\n    return result;\n  }\n  async saveArtifactAndDebugFile(artifact, pathToBuildInfo) {\n    try {\n      // artifact\n      const fullyQualifiedName = (0, contract_names_1.getFullyQualifiedName)(artifact.sourceName, artifact.contractName);\n      const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n      await fs_extra_1.default.ensureDir(path.dirname(artifactPath));\n      await Promise.all([fs_extra_1.default.writeJSON(artifactPath, artifact, {\n        spaces: 2\n      }), (async () => {\n        if (pathToBuildInfo === undefined) {\n          return;\n        }\n        // save debug file\n        const debugFilePath = this._getDebugFilePath(artifactPath);\n        const debugFile = this._createDebugFile(artifactPath, pathToBuildInfo);\n        await fs_extra_1.default.writeJSON(debugFilePath, debugFile, {\n          spaces: 2\n        });\n      })()]);\n    } finally {\n      this.clearCache();\n    }\n  }\n  async saveBuildInfo(solcVersion, solcLongVersion, input, output) {\n    try {\n      const buildInfoDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n      await fs_extra_1.default.ensureDir(buildInfoDir);\n      const buildInfoName = this._getBuildInfoName(solcVersion, solcLongVersion, input);\n      const buildInfo = this._createBuildInfo(buildInfoName, solcVersion, solcLongVersion, input, output);\n      const buildInfoPath = path.join(buildInfoDir, `${buildInfoName}.json`);\n      // JSON.stringify of the entire build info can be really slow\n      // in larger projects, so we stringify per part and incrementally create\n      // the JSON in the file.\n      //\n      // We split this code into different curly-brace-enclosed scopes so that\n      // partial JSON strings get out of scope sooner and hence can be reclaimed\n      // by the GC if needed.\n      const file = await promises_1.default.open(buildInfoPath, \"w\");\n      try {\n        {\n          const withoutOutput = JSON.stringify({\n            ...buildInfo,\n            output: undefined\n          });\n          // We write the JSON (without output) except the last }\n          await file.write(withoutOutput.slice(0, -1));\n        }\n        {\n          const outputWithoutSourcesAndContracts = JSON.stringify({\n            ...buildInfo.output,\n            sources: undefined,\n            contracts: undefined\n          });\n          // We start writing the output\n          await file.write(',\"output\":');\n          // Write the output object except for the last }\n          await file.write(outputWithoutSourcesAndContracts.slice(0, -1));\n          // If there were other field apart from sources and contracts we need\n          // a comma\n          if (outputWithoutSourcesAndContracts.length > 2) {\n            await file.write(\",\");\n          }\n        }\n        // Writing the sources\n        await file.write('\"sources\":{');\n        let isFirst = true;\n        for (const [name, value] of Object.entries(buildInfo.output.sources ?? {})) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        }\n        // Close sources object\n        await file.write(\"}\");\n        // Writing the contracts\n        await file.write(',\"contracts\":{');\n        isFirst = true;\n        for (const [name, value] of Object.entries(buildInfo.output.contracts ?? {})) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        }\n        // close contracts object\n        await file.write(\"}\");\n        // close output object\n        await file.write(\"}\");\n        // close build info object\n        await file.write(\"}\");\n      } finally {\n        await file.close();\n      }\n      return buildInfoPath;\n    } finally {\n      this.clearCache();\n    }\n  }\n  /**\n   * Remove all artifacts that don't correspond to the current solidity files\n   */\n  async removeObsoleteArtifacts() {\n    // We clear the cache here, as we want to be sure this runs correctly\n    this.clearCache();\n    try {\n      const validArtifactPaths = await Promise.all(this._validArtifacts.flatMap(_ref => {\n        let {\n          sourceName,\n          artifacts\n        } = _ref;\n        return artifacts.map(artifactName => this._getArtifactPath((0, contract_names_1.getFullyQualifiedName)(sourceName, artifactName)));\n      }));\n      const validArtifactsPathsSet = new Set(validArtifactPaths);\n      for (const {\n        sourceName,\n        artifacts\n      } of this._validArtifacts) {\n        for (const artifactName of artifacts) {\n          validArtifactsPathsSet.add(this.formArtifactPathFromFullyQualifiedName((0, contract_names_1.getFullyQualifiedName)(sourceName, artifactName)));\n        }\n      }\n      const existingArtifactsPaths = await this.getArtifactPaths();\n      await Promise.all(existingArtifactsPaths.filter(artifactPath => !validArtifactsPathsSet.has(artifactPath)).map(artifactPath => this._removeArtifactFiles(artifactPath)));\n      await this._removeObsoleteBuildInfos();\n    } finally {\n      // We clear the cache here, as this may have non-existent paths now\n      this.clearCache();\n    }\n  }\n  /**\n   * Returns the absolute path to the given artifact\n   */\n  formArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const {\n      sourceName,\n      contractName\n    } = (0, contract_names_1.parseFullyQualifiedName)(fullyQualifiedName);\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n  clearCache() {\n    // Avoid accidentally re-enabling the cache\n    if (this._cache === undefined) {\n      return;\n    }\n    this._cache = {\n      artifactFQNToBuildInfoPathCache: new Map(),\n      artifactNameToArtifactPathCache: new Map()\n    };\n  }\n  disableCache() {\n    this._cache = undefined;\n  }\n  /**\n   * Remove all build infos that aren't used by any debug file\n   */\n  async _removeObsoleteBuildInfos() {\n    const debugFiles = await this.getDebugFilePaths();\n    const buildInfos = await Promise.all(debugFiles.map(async debugFile => {\n      const buildInfoFile = await this._getBuildInfoFromDebugFile(debugFile);\n      if (buildInfoFile !== undefined) {\n        return path.resolve(path.dirname(debugFile), buildInfoFile);\n      } else {\n        return undefined;\n      }\n    }));\n    const filteredBuildInfos = buildInfos.filter(bf => typeof bf === \"string\");\n    const validBuildInfos = new Set(filteredBuildInfos);\n    const buildInfoFiles = await this.getBuildInfoPaths();\n    await Promise.all(buildInfoFiles.filter(buildInfoFile => !validBuildInfos.has(buildInfoFile)).map(async buildInfoFile => {\n      log(`Removing buildInfo '${buildInfoFile}'`);\n      await fs_extra_1.default.unlink(buildInfoFile);\n    }));\n  }\n  _getBuildInfoName(solcVersion, solcLongVersion, input) {\n    const json = JSON.stringify({\n      _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input\n    });\n    return (0, hash_1.createNonCryptographicHashBasedIdentifier)(Buffer.from(json)).toString(\"hex\");\n  }\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * name.\n   *\n   * If the name is fully qualified, the path is computed from it.  If not, an\n   * artifact that matches the given name is searched in the existing artifacts.\n   * If there is an ambiguity, an error is thrown.\n   */\n  async _getArtifactPath(name) {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n    if (cached !== undefined) {\n      return cached;\n    }\n    let result;\n    if ((0, contract_names_1.isFullyQualifiedName)(name)) {\n      result = await this._getValidArtifactPathFromFullyQualifiedName(name);\n    } else {\n      const files = await this.getArtifactPaths();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n  _createBuildInfo(id, solcVersion, solcLongVersion, input, output) {\n    return {\n      id,\n      _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n      output\n    };\n  }\n  _createDebugFile(artifactPath, pathToBuildInfo) {\n    const relativePathToBuildInfo = path.relative(path.dirname(artifactPath), pathToBuildInfo);\n    const debugFile = {\n      _format: constants_1.DEBUG_FILE_FORMAT_VERSION,\n      buildInfo: relativePathToBuildInfo\n    };\n    return debugFile;\n  }\n  _getArtifactPathsSync() {\n    const cached = this._cache?.artifactPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n    const buildInfosDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n    const paths = (0, fs_utils_1.getAllFilesMatchingSync)(this._artifactsPath, f => f.endsWith(\".json\") && !f.startsWith(buildInfosDir) && !f.endsWith(\".dbg.json\"));\n    const result = paths.sort();\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n    return result;\n  }\n  /**\n   * Sync version of _getArtifactPath\n   */\n  _getArtifactPathSync(name) {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n    if (cached !== undefined) {\n      return cached;\n    }\n    let result;\n    if ((0, contract_names_1.isFullyQualifiedName)(name)) {\n      result = this._getValidArtifactPathFromFullyQualifiedNameSync(name);\n    } else {\n      const files = this._getArtifactPathsSync();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n  /**\n   * DO NOT DELETE OR CHANGE\n   *\n   * use this.formArtifactPathFromFullyQualifiedName instead\n   * @deprecated until typechain migrates to public version\n   * @see https://github.com/dethcrypto/TypeChain/issues/544\n   */\n  _getArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const {\n      sourceName,\n      contractName\n    } = (0, contract_names_1.parseFullyQualifiedName)(fullyQualifiedName);\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n  async _getValidArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n    try {\n      const trueCasePath = path.join(this._artifactsPath, await (0, fs_utils_1.getFileTrueCase)(this._artifactsPath, path.relative(this._artifactsPath, artifactPath)));\n      if (artifactPath !== trueCasePath) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName\n        });\n      }\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof fs_utils_1.FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(fullyQualifiedName);\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n  _getAllContractNamesFromFiles(files) {\n    return files.map(file => {\n      const fqn = this._getFullyQualifiedNameFromPath(file);\n      return (0, contract_names_1.parseFullyQualifiedName)(fqn).contractName;\n    });\n  }\n  _getAllFullyQualifiedNamesSync() {\n    const paths = this._getArtifactPathsSync();\n    return paths.map(p => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n  _formatSuggestions(names, contractName) {\n    switch (names.length) {\n      case 0:\n        return \"\";\n      case 1:\n        return `Did you mean \"${names[0]}\"?`;\n      default:\n        return `We found some that were similar:\n\n${names.map(n => `  * ${n}`).join(os.EOL)}\n\nPlease replace \"${contractName}\" for the correct contract name wherever you are trying to read its artifact.\n`;\n    }\n  }\n  _handleWrongArtifactForFullyQualifiedName(fullyQualifiedName) {\n    const names = this._getAllFullyQualifiedNamesSync();\n    const similarNames = this._getSimilarContractNames(fullyQualifiedName, names);\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName: fullyQualifiedName,\n      suggestion: this._formatSuggestions(similarNames, fullyQualifiedName)\n    });\n  }\n  _handleWrongArtifactForContractName(contractName, files) {\n    const names = this._getAllContractNamesFromFiles(files);\n    let similarNames = this._getSimilarContractNames(contractName, names);\n    if (similarNames.length > 1) {\n      similarNames = this._filterDuplicatesAsFullyQualifiedNames(files, similarNames);\n    }\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName,\n      suggestion: this._formatSuggestions(similarNames, contractName)\n    });\n  }\n  /**\n   * If the project has these contracts:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'contracts/Greater.sol:Greater'\n   *  And the user tries to get an artifact with the name 'Greter', then\n   *  the suggestions will be 'Greeter', 'Greeter', and 'Greater'.\n   *\n   * We don't want to show duplicates here, so we use FQNs for those. The\n   * suggestions will then be:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'Greater'\n   */\n  _filterDuplicatesAsFullyQualifiedNames(files, similarNames) {\n    const outputNames = [];\n    const groups = similarNames.reduce((obj, cur) => {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      obj[cur] = obj[cur] ? obj[cur] + 1 : 1;\n      return obj;\n    }, {});\n    for (const [name, occurrences] of Object.entries(groups)) {\n      if (occurrences > 1) {\n        for (const file of files) {\n          if (path.basename(file) === `${name}.json`) {\n            outputNames.push(this._getFullyQualifiedNameFromPath(file));\n          }\n        }\n        continue;\n      }\n      outputNames.push(name);\n    }\n    return outputNames;\n  }\n  /**\n   *\n   * @param givenName can be FQN or contract name\n   * @param names MUST match type of givenName (i.e. array of FQN's if givenName is FQN)\n   * @returns\n   */\n  _getSimilarContractNames(givenName, names) {\n    let shortestDistance = constants_1.EDIT_DISTANCE_THRESHOLD;\n    let mostSimilarNames = [];\n    for (const name of names) {\n      const distance = (0, contract_names_1.findDistance)(givenName, name);\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        mostSimilarNames = [name];\n        continue;\n      }\n      if (distance === shortestDistance) {\n        mostSimilarNames.push(name);\n        continue;\n      }\n    }\n    return mostSimilarNames;\n  }\n  _getValidArtifactPathFromFullyQualifiedNameSync(fullyQualifiedName) {\n    const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n    try {\n      const trueCasePath = path.join(this._artifactsPath, (0, fs_utils_1.getFileTrueCaseSync)(this._artifactsPath, path.relative(this._artifactsPath, artifactPath)));\n      if (artifactPath !== trueCasePath) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName\n        });\n      }\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof fs_utils_1.FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(fullyQualifiedName);\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n  _getDebugFilePath(artifactPath) {\n    return artifactPath.replace(/\\.json$/, \".dbg.json\");\n  }\n  _getArtifactPathFromFiles(contractName, files) {\n    const matchingFiles = files.filter(file => {\n      return path.basename(file) === `${contractName}.json`;\n    });\n    if (matchingFiles.length === 0) {\n      return this._handleWrongArtifactForContractName(contractName, files);\n    }\n    if (matchingFiles.length > 1) {\n      const candidates = matchingFiles.map(file => this._getFullyQualifiedNameFromPath(file));\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.MULTIPLE_FOUND, {\n        contractName,\n        candidates: candidates.join(os.EOL)\n      });\n    }\n    return matchingFiles[0];\n  }\n  /**\n   * Returns the FQN of a contract giving the absolute path to its artifact.\n   *\n   * For example, given a path like\n   * `/path/to/project/artifacts/contracts/Foo.sol/Bar.json`, it'll return the\n   * FQN `contracts/Foo.sol:Bar`\n   */\n  _getFullyQualifiedNameFromPath(absolutePath) {\n    const sourceName = (0, source_names_1.replaceBackslashes)(path.relative(this._artifactsPath, path.dirname(absolutePath)));\n    const contractName = path.basename(absolutePath).replace(\".json\", \"\");\n    return (0, contract_names_1.getFullyQualifiedName)(sourceName, contractName);\n  }\n  /**\n   * Remove the artifact file, its debug file and, if it exists, its build\n   * info file.\n   */\n  async _removeArtifactFiles(artifactPath) {\n    await fs_extra_1.default.remove(artifactPath);\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n    const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n    await fs_extra_1.default.remove(debugFilePath);\n    if (buildInfoPath !== undefined) {\n      await fs_extra_1.default.remove(buildInfoPath);\n    }\n  }\n  /**\n   * Given the path to a debug file, returns the absolute path to its\n   * corresponding build info file if it exists, or undefined otherwise.\n   */\n  async _getBuildInfoFromDebugFile(debugFilePath) {\n    if (await fs_extra_1.default.pathExists(debugFilePath)) {\n      const {\n        buildInfo\n      } = await fs_extra_1.default.readJson(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n    return undefined;\n  }\n}\nexports.Artifacts = Artifacts;\n/**\n * Retrieves an artifact for the given `contractName` from the compilation output.\n *\n * @param sourceName The contract's source name.\n * @param contractName the contract's name.\n * @param contractOutput the contract's compilation output as emitted by `solc`.\n */\nfunction getArtifactFromContractOutput(sourceName, contractName, contractOutput) {\n  const evmBytecode = contractOutput.evm && contractOutput.evm.bytecode;\n  let bytecode = evmBytecode && evmBytecode.object ? evmBytecode.object : \"\";\n  if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    bytecode = `0x${bytecode}`;\n  }\n  const evmDeployedBytecode = contractOutput.evm && contractOutput.evm.deployedBytecode;\n  let deployedBytecode = evmDeployedBytecode && evmDeployedBytecode.object ? evmDeployedBytecode.object : \"\";\n  if (deployedBytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    deployedBytecode = `0x${deployedBytecode}`;\n  }\n  const linkReferences = evmBytecode && evmBytecode.linkReferences ? evmBytecode.linkReferences : {};\n  const deployedLinkReferences = evmDeployedBytecode && evmDeployedBytecode.linkReferences ? evmDeployedBytecode.linkReferences : {};\n  return {\n    _format: constants_1.ARTIFACT_FORMAT_VERSION,\n    contractName,\n    sourceName,\n    abi: contractOutput.abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences\n  };\n}\nexports.getArtifactFromContractOutput = getArtifactFromContractOutput;","map":{"version":3,"mappings":"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","names":["log","Artifacts","constructor","_artifactsPath","artifactNameToArtifactPathCache","Map","artifactFQNToBuildInfoPathCache","_validArtifacts","addValidArtifacts","validArtifacts","push","readArtifact","name","artifactPath","_getArtifactPath","fs_extra_1","readJson","readArtifactSync","_getArtifactPathSync","readJsonSync","artifactExists","pathExists","getAllFullyQualifiedNames","paths","getArtifactPaths","map","p","_getFullyQualifiedNameFromPath","sort","getBuildInfo","fullyQualifiedName","buildInfoPath","_cache","get","undefined","formArtifactPathFromFullyQualifiedName","debugFilePath","_getDebugFilePath","_getBuildInfoFromDebugFile","set","readJSON","cached","artifactPaths","buildInfosDir","path","join","constants_1","f","endsWith","startsWith","result","getBuildInfoPaths","buildInfoPaths","getDebugFilePaths","debugFilePaths","saveArtifactAndDebugFile","artifact","pathToBuildInfo","sourceName","contractName","ensureDir","dirname","Promise","all","writeJSON","spaces","debugFile","_createDebugFile","clearCache","saveBuildInfo","solcVersion","solcLongVersion","input","output","buildInfoDir","buildInfoName","_getBuildInfoName","buildInfo","_createBuildInfo","file","promises_1","open","withoutOutput","JSON","stringify","write","slice","outputWithoutSourcesAndContracts","sources","contracts","length","isFirst","value","Object","entries","close","removeObsoleteArtifacts","validArtifactPaths","flatMap","artifacts","artifactName","validArtifactsPathsSet","Set","add","existingArtifactsPaths","filter","has","_removeArtifactFiles","_removeObsoleteBuildInfos","disableCache","debugFiles","buildInfos","buildInfoFile","resolve","filteredBuildInfos","bf","validBuildInfos","buildInfoFiles","unlink","json","_format","Buffer","from","toString","_getValidArtifactPathFromFullyQualifiedName","files","_getArtifactPathFromFiles","id","relativePathToBuildInfo","relative","_getArtifactPathsSync","_getValidArtifactPathFromFullyQualifiedNameSync","_getArtifactPathFromFullyQualifiedName","trueCasePath","errors_1","errors_list_1","ARTIFACTS","WRONG_CASING","correct","incorrect","e","fs_utils_1","_handleWrongArtifactForFullyQualifiedName","_getAllContractNamesFromFiles","fqn","_getAllFullyQualifiedNamesSync","_formatSuggestions","names","n","os","EOL","similarNames","_getSimilarContractNames","NOT_FOUND","suggestion","_handleWrongArtifactForContractName","_filterDuplicatesAsFullyQualifiedNames","outputNames","groups","reduce","obj","cur","occurrences","basename","givenName","shortestDistance","mostSimilarNames","distance","replace","matchingFiles","candidates","MULTIPLE_FOUND","absolutePath","remove","exports","getArtifactFromContractOutput","contractOutput","evmBytecode","evm","bytecode","object","toLowerCase","evmDeployedBytecode","deployedBytecode","linkReferences","deployedLinkReferences","abi"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/hardhat/src/internal/artifacts.ts"],"sourcesContent":["import debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport fsPromises from \"fs/promises\";\n\nimport {\n  Artifact,\n  Artifacts as IArtifacts,\n  BuildInfo,\n  CompilerInput,\n  CompilerOutput,\n  DebugFile,\n} from \"../types\";\nimport {\n  getFullyQualifiedName,\n  isFullyQualifiedName,\n  parseFullyQualifiedName,\n  findDistance,\n} from \"../utils/contract-names\";\nimport { replaceBackslashes } from \"../utils/source-names\";\n\nimport {\n  ARTIFACT_FORMAT_VERSION,\n  BUILD_INFO_DIR_NAME,\n  BUILD_INFO_FORMAT_VERSION,\n  DEBUG_FILE_FORMAT_VERSION,\n  EDIT_DISTANCE_THRESHOLD,\n} from \"./constants\";\nimport { HardhatError } from \"./core/errors\";\nimport { ERRORS } from \"./core/errors-list\";\nimport { createNonCryptographicHashBasedIdentifier } from \"./util/hash\";\nimport {\n  FileNotFoundError,\n  getAllFilesMatching,\n  getAllFilesMatchingSync,\n  getFileTrueCase,\n  getFileTrueCaseSync,\n} from \"./util/fs-utils\";\n\nconst log = debug(\"hardhat:core:artifacts\");\n\ninterface Cache {\n  artifactPaths?: string[];\n  debugFilePaths?: string[];\n  buildInfoPaths?: string[];\n  artifactNameToArtifactPathCache: Map<string, string>;\n  artifactFQNToBuildInfoPathCache: Map<string, string>;\n}\n\nexport class Artifacts implements IArtifacts {\n  private _validArtifacts: Array<{ sourceName: string; artifacts: string[] }>;\n\n  // Undefined means that the cache is disabled.\n  private _cache?: Cache = {\n    artifactNameToArtifactPathCache: new Map(),\n    artifactFQNToBuildInfoPathCache: new Map(),\n  };\n\n  constructor(private _artifactsPath: string) {\n    this._validArtifacts = [];\n  }\n\n  public addValidArtifacts(\n    validArtifacts: Array<{ sourceName: string; artifacts: string[] }>\n  ) {\n    this._validArtifacts.push(...validArtifacts);\n  }\n\n  public async readArtifact(name: string): Promise<Artifact> {\n    const artifactPath = await this._getArtifactPath(name);\n    return fsExtra.readJson(artifactPath);\n  }\n\n  public readArtifactSync(name: string): Artifact {\n    const artifactPath = this._getArtifactPathSync(name);\n    return fsExtra.readJsonSync(artifactPath);\n  }\n\n  public async artifactExists(name: string): Promise<boolean> {\n    const artifactPath = await this._getArtifactPath(name);\n    return fsExtra.pathExists(artifactPath);\n  }\n\n  public async getAllFullyQualifiedNames(): Promise<string[]> {\n    const paths = await this.getArtifactPaths();\n    return paths.map((p) => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  public async getBuildInfo(\n    fullyQualifiedName: string\n  ): Promise<BuildInfo | undefined> {\n    let buildInfoPath =\n      this._cache?.artifactFQNToBuildInfoPathCache.get(fullyQualifiedName);\n\n    if (buildInfoPath === undefined) {\n      const artifactPath =\n        this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n      const debugFilePath = this._getDebugFilePath(artifactPath);\n      buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n\n      if (buildInfoPath === undefined) {\n        return undefined;\n      }\n\n      this._cache?.artifactFQNToBuildInfoPathCache.set(\n        fullyQualifiedName,\n        buildInfoPath\n      );\n    }\n\n    return fsExtra.readJSON(buildInfoPath);\n  }\n\n  public async getArtifactPaths(): Promise<string[]> {\n    const cached = this._cache?.artifactPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const buildInfosDir = path.join(this._artifactsPath, BUILD_INFO_DIR_NAME);\n\n    const paths = await getAllFilesMatching(\n      this._artifactsPath,\n      (f) =>\n        f.endsWith(\".json\") &&\n        !f.startsWith(buildInfosDir) &&\n        !f.endsWith(\".dbg.json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n\n    return result;\n  }\n\n  public async getBuildInfoPaths(): Promise<string[]> {\n    const cached = this._cache?.buildInfoPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const paths = await getAllFilesMatching(\n      path.join(this._artifactsPath, BUILD_INFO_DIR_NAME),\n      (f) => f.endsWith(\".json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.buildInfoPaths = result;\n    }\n\n    return result;\n  }\n\n  public async getDebugFilePaths(): Promise<string[]> {\n    const cached = this._cache?.debugFilePaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const paths = await getAllFilesMatching(\n      path.join(this._artifactsPath),\n      (f) => f.endsWith(\".dbg.json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.debugFilePaths = result;\n    }\n\n    return result;\n  }\n\n  public async saveArtifactAndDebugFile(\n    artifact: Artifact,\n    pathToBuildInfo?: string\n  ) {\n    try {\n      // artifact\n      const fullyQualifiedName = getFullyQualifiedName(\n        artifact.sourceName,\n        artifact.contractName\n      );\n\n      const artifactPath =\n        this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n      await fsExtra.ensureDir(path.dirname(artifactPath));\n\n      await Promise.all([\n        fsExtra.writeJSON(artifactPath, artifact, {\n          spaces: 2,\n        }),\n        (async () => {\n          if (pathToBuildInfo === undefined) {\n            return;\n          }\n\n          // save debug file\n          const debugFilePath = this._getDebugFilePath(artifactPath);\n          const debugFile = this._createDebugFile(\n            artifactPath,\n            pathToBuildInfo\n          );\n\n          await fsExtra.writeJSON(debugFilePath, debugFile, {\n            spaces: 2,\n          });\n        })(),\n      ]);\n    } finally {\n      this.clearCache();\n    }\n  }\n\n  public async saveBuildInfo(\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput,\n    output: CompilerOutput\n  ): Promise<string> {\n    try {\n      const buildInfoDir = path.join(this._artifactsPath, BUILD_INFO_DIR_NAME);\n      await fsExtra.ensureDir(buildInfoDir);\n\n      const buildInfoName = this._getBuildInfoName(\n        solcVersion,\n        solcLongVersion,\n        input\n      );\n\n      const buildInfo = this._createBuildInfo(\n        buildInfoName,\n        solcVersion,\n        solcLongVersion,\n        input,\n        output\n      );\n\n      const buildInfoPath = path.join(buildInfoDir, `${buildInfoName}.json`);\n\n      // JSON.stringify of the entire build info can be really slow\n      // in larger projects, so we stringify per part and incrementally create\n      // the JSON in the file.\n      //\n      // We split this code into different curly-brace-enclosed scopes so that\n      // partial JSON strings get out of scope sooner and hence can be reclaimed\n      // by the GC if needed.\n      const file = await fsPromises.open(buildInfoPath, \"w\");\n      try {\n        {\n          const withoutOutput = JSON.stringify({\n            ...buildInfo,\n            output: undefined,\n          });\n\n          // We write the JSON (without output) except the last }\n          await file.write(withoutOutput.slice(0, -1));\n        }\n\n        {\n          const outputWithoutSourcesAndContracts = JSON.stringify({\n            ...buildInfo.output,\n            sources: undefined,\n            contracts: undefined,\n          });\n\n          // We start writing the output\n          await file.write(',\"output\":');\n\n          // Write the output object except for the last }\n          await file.write(outputWithoutSourcesAndContracts.slice(0, -1));\n\n          // If there were other field apart from sources and contracts we need\n          // a comma\n          if (outputWithoutSourcesAndContracts.length > 2) {\n            await file.write(\",\");\n          }\n        }\n\n        // Writing the sources\n        await file.write('\"sources\":{');\n\n        let isFirst = true;\n        for (const [name, value] of Object.entries(\n          buildInfo.output.sources ?? {}\n        )) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        }\n\n        // Close sources object\n        await file.write(\"}\");\n\n        // Writing the contracts\n        await file.write(',\"contracts\":{');\n\n        isFirst = true;\n        for (const [name, value] of Object.entries(\n          buildInfo.output.contracts ?? {}\n        )) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        }\n\n        // close contracts object\n        await file.write(\"}\");\n        // close output object\n        await file.write(\"}\");\n        // close build info object\n        await file.write(\"}\");\n      } finally {\n        await file.close();\n      }\n\n      return buildInfoPath;\n    } finally {\n      this.clearCache();\n    }\n  }\n\n  /**\n   * Remove all artifacts that don't correspond to the current solidity files\n   */\n  public async removeObsoleteArtifacts() {\n    // We clear the cache here, as we want to be sure this runs correctly\n    this.clearCache();\n\n    try {\n      const validArtifactPaths = await Promise.all(\n        this._validArtifacts.flatMap(({ sourceName, artifacts }) =>\n          artifacts.map((artifactName) =>\n            this._getArtifactPath(\n              getFullyQualifiedName(sourceName, artifactName)\n            )\n          )\n        )\n      );\n\n      const validArtifactsPathsSet = new Set<string>(validArtifactPaths);\n\n      for (const { sourceName, artifacts } of this._validArtifacts) {\n        for (const artifactName of artifacts) {\n          validArtifactsPathsSet.add(\n            this.formArtifactPathFromFullyQualifiedName(\n              getFullyQualifiedName(sourceName, artifactName)\n            )\n          );\n        }\n      }\n\n      const existingArtifactsPaths = await this.getArtifactPaths();\n\n      await Promise.all(\n        existingArtifactsPaths\n          .filter((artifactPath) => !validArtifactsPathsSet.has(artifactPath))\n          .map((artifactPath) => this._removeArtifactFiles(artifactPath))\n      );\n\n      await this._removeObsoleteBuildInfos();\n    } finally {\n      // We clear the cache here, as this may have non-existent paths now\n      this.clearCache();\n    }\n  }\n\n  /**\n   * Returns the absolute path to the given artifact\n   */\n  public formArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): string {\n    const { sourceName, contractName } =\n      parseFullyQualifiedName(fullyQualifiedName);\n\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  public clearCache() {\n    // Avoid accidentally re-enabling the cache\n    if (this._cache === undefined) {\n      return;\n    }\n\n    this._cache = {\n      artifactFQNToBuildInfoPathCache: new Map(),\n      artifactNameToArtifactPathCache: new Map(),\n    };\n  }\n\n  public disableCache() {\n    this._cache = undefined;\n  }\n\n  /**\n   * Remove all build infos that aren't used by any debug file\n   */\n  private async _removeObsoleteBuildInfos() {\n    const debugFiles = await this.getDebugFilePaths();\n\n    const buildInfos = await Promise.all(\n      debugFiles.map(async (debugFile) => {\n        const buildInfoFile = await this._getBuildInfoFromDebugFile(debugFile);\n        if (buildInfoFile !== undefined) {\n          return path.resolve(path.dirname(debugFile), buildInfoFile);\n        } else {\n          return undefined;\n        }\n      })\n    );\n\n    const filteredBuildInfos: string[] = buildInfos.filter(\n      (bf): bf is string => typeof bf === \"string\"\n    );\n\n    const validBuildInfos = new Set<string>(filteredBuildInfos);\n\n    const buildInfoFiles = await this.getBuildInfoPaths();\n\n    await Promise.all(\n      buildInfoFiles\n        .filter((buildInfoFile) => !validBuildInfos.has(buildInfoFile))\n        .map(async (buildInfoFile) => {\n          log(`Removing buildInfo '${buildInfoFile}'`);\n          await fsExtra.unlink(buildInfoFile);\n        })\n    );\n  }\n\n  private _getBuildInfoName(\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput\n  ): string {\n    const json = JSON.stringify({\n      _format: BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n    });\n\n    return createNonCryptographicHashBasedIdentifier(\n      Buffer.from(json)\n    ).toString(\"hex\");\n  }\n\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * name.\n   *\n   * If the name is fully qualified, the path is computed from it.  If not, an\n   * artifact that matches the given name is searched in the existing artifacts.\n   * If there is an ambiguity, an error is thrown.\n   */\n  private async _getArtifactPath(name: string): Promise<string> {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    let result: string;\n    if (isFullyQualifiedName(name)) {\n      result = await this._getValidArtifactPathFromFullyQualifiedName(name);\n    } else {\n      const files = await this.getArtifactPaths();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n\n  private _createBuildInfo(\n    id: string,\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput,\n    output: CompilerOutput\n  ): BuildInfo {\n    return {\n      id,\n      _format: BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n      output,\n    };\n  }\n\n  private _createDebugFile(artifactPath: string, pathToBuildInfo: string) {\n    const relativePathToBuildInfo = path.relative(\n      path.dirname(artifactPath),\n      pathToBuildInfo\n    );\n\n    const debugFile: DebugFile = {\n      _format: DEBUG_FILE_FORMAT_VERSION,\n      buildInfo: relativePathToBuildInfo,\n    };\n\n    return debugFile;\n  }\n\n  private _getArtifactPathsSync(): string[] {\n    const cached = this._cache?.artifactPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const buildInfosDir = path.join(this._artifactsPath, BUILD_INFO_DIR_NAME);\n\n    const paths = getAllFilesMatchingSync(\n      this._artifactsPath,\n      (f) =>\n        f.endsWith(\".json\") &&\n        !f.startsWith(buildInfosDir) &&\n        !f.endsWith(\".dbg.json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n\n    return result;\n  }\n\n  /**\n   * Sync version of _getArtifactPath\n   */\n  private _getArtifactPathSync(name: string): string {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    let result: string;\n\n    if (isFullyQualifiedName(name)) {\n      result = this._getValidArtifactPathFromFullyQualifiedNameSync(name);\n    } else {\n      const files = this._getArtifactPathsSync();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n\n  /**\n   * DO NOT DELETE OR CHANGE\n   *\n   * use this.formArtifactPathFromFullyQualifiedName instead\n   * @deprecated until typechain migrates to public version\n   * @see https://github.com/dethcrypto/TypeChain/issues/544\n   */\n  private _getArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): string {\n    const { sourceName, contractName } =\n      parseFullyQualifiedName(fullyQualifiedName);\n\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  private async _getValidArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): Promise<string> {\n    const artifactPath =\n      this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    try {\n      const trueCasePath = path.join(\n        this._artifactsPath,\n        await getFileTrueCase(\n          this._artifactsPath,\n          path.relative(this._artifactsPath, artifactPath)\n        )\n      );\n\n      if (artifactPath !== trueCasePath) {\n        throw new HardhatError(ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName,\n        });\n      }\n\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(\n          fullyQualifiedName\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  private _getAllContractNamesFromFiles(files: string[]): string[] {\n    return files.map((file) => {\n      const fqn = this._getFullyQualifiedNameFromPath(file);\n      return parseFullyQualifiedName(fqn).contractName;\n    });\n  }\n\n  private _getAllFullyQualifiedNamesSync(): string[] {\n    const paths = this._getArtifactPathsSync();\n    return paths.map((p) => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  private _formatSuggestions(names: string[], contractName: string): string {\n    switch (names.length) {\n      case 0:\n        return \"\";\n      case 1:\n        return `Did you mean \"${names[0]}\"?`;\n      default:\n        return `We found some that were similar:\n\n${names.map((n) => `  * ${n}`).join(os.EOL)}\n\nPlease replace \"${contractName}\" for the correct contract name wherever you are trying to read its artifact.\n`;\n    }\n  }\n\n  private _handleWrongArtifactForFullyQualifiedName(\n    fullyQualifiedName: string\n  ): never {\n    const names = this._getAllFullyQualifiedNamesSync();\n\n    const similarNames = this._getSimilarContractNames(\n      fullyQualifiedName,\n      names\n    );\n\n    throw new HardhatError(ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName: fullyQualifiedName,\n      suggestion: this._formatSuggestions(similarNames, fullyQualifiedName),\n    });\n  }\n\n  private _handleWrongArtifactForContractName(\n    contractName: string,\n    files: string[]\n  ): never {\n    const names = this._getAllContractNamesFromFiles(files);\n\n    let similarNames = this._getSimilarContractNames(contractName, names);\n\n    if (similarNames.length > 1) {\n      similarNames = this._filterDuplicatesAsFullyQualifiedNames(\n        files,\n        similarNames\n      );\n    }\n\n    throw new HardhatError(ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName,\n      suggestion: this._formatSuggestions(similarNames, contractName),\n    });\n  }\n\n  /**\n   * If the project has these contracts:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'contracts/Greater.sol:Greater'\n   *  And the user tries to get an artifact with the name 'Greter', then\n   *  the suggestions will be 'Greeter', 'Greeter', and 'Greater'.\n   *\n   * We don't want to show duplicates here, so we use FQNs for those. The\n   * suggestions will then be:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'Greater'\n   */\n  private _filterDuplicatesAsFullyQualifiedNames(\n    files: string[],\n    similarNames: string[]\n  ): string[] {\n    const outputNames = [];\n    const groups = similarNames.reduce((obj, cur) => {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      obj[cur] = obj[cur] ? obj[cur] + 1 : 1;\n      return obj;\n    }, {} as { [k: string]: number });\n\n    for (const [name, occurrences] of Object.entries(groups)) {\n      if (occurrences > 1) {\n        for (const file of files) {\n          if (path.basename(file) === `${name}.json`) {\n            outputNames.push(this._getFullyQualifiedNameFromPath(file));\n          }\n        }\n        continue;\n      }\n\n      outputNames.push(name);\n    }\n\n    return outputNames;\n  }\n\n  /**\n   *\n   * @param givenName can be FQN or contract name\n   * @param names MUST match type of givenName (i.e. array of FQN's if givenName is FQN)\n   * @returns\n   */\n  private _getSimilarContractNames(\n    givenName: string,\n    names: string[]\n  ): string[] {\n    let shortestDistance = EDIT_DISTANCE_THRESHOLD;\n    let mostSimilarNames: string[] = [];\n    for (const name of names) {\n      const distance = findDistance(givenName, name);\n\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        mostSimilarNames = [name];\n        continue;\n      }\n\n      if (distance === shortestDistance) {\n        mostSimilarNames.push(name);\n        continue;\n      }\n    }\n\n    return mostSimilarNames;\n  }\n\n  private _getValidArtifactPathFromFullyQualifiedNameSync(\n    fullyQualifiedName: string\n  ): string {\n    const artifactPath =\n      this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    try {\n      const trueCasePath = path.join(\n        this._artifactsPath,\n        getFileTrueCaseSync(\n          this._artifactsPath,\n          path.relative(this._artifactsPath, artifactPath)\n        )\n      );\n\n      if (artifactPath !== trueCasePath) {\n        throw new HardhatError(ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName,\n        });\n      }\n\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(\n          fullyQualifiedName\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  private _getDebugFilePath(artifactPath: string): string {\n    return artifactPath.replace(/\\.json$/, \".dbg.json\");\n  }\n\n  private _getArtifactPathFromFiles(\n    contractName: string,\n    files: string[]\n  ): string {\n    const matchingFiles = files.filter((file) => {\n      return path.basename(file) === `${contractName}.json`;\n    });\n\n    if (matchingFiles.length === 0) {\n      return this._handleWrongArtifactForContractName(contractName, files);\n    }\n\n    if (matchingFiles.length > 1) {\n      const candidates = matchingFiles.map((file) =>\n        this._getFullyQualifiedNameFromPath(file)\n      );\n\n      throw new HardhatError(ERRORS.ARTIFACTS.MULTIPLE_FOUND, {\n        contractName,\n        candidates: candidates.join(os.EOL),\n      });\n    }\n\n    return matchingFiles[0];\n  }\n\n  /**\n   * Returns the FQN of a contract giving the absolute path to its artifact.\n   *\n   * For example, given a path like\n   * `/path/to/project/artifacts/contracts/Foo.sol/Bar.json`, it'll return the\n   * FQN `contracts/Foo.sol:Bar`\n   */\n  private _getFullyQualifiedNameFromPath(absolutePath: string): string {\n    const sourceName = replaceBackslashes(\n      path.relative(this._artifactsPath, path.dirname(absolutePath))\n    );\n\n    const contractName = path.basename(absolutePath).replace(\".json\", \"\");\n\n    return getFullyQualifiedName(sourceName, contractName);\n  }\n\n  /**\n   * Remove the artifact file, its debug file and, if it exists, its build\n   * info file.\n   */\n  private async _removeArtifactFiles(artifactPath: string) {\n    await fsExtra.remove(artifactPath);\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n    const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n\n    await fsExtra.remove(debugFilePath);\n\n    if (buildInfoPath !== undefined) {\n      await fsExtra.remove(buildInfoPath);\n    }\n  }\n\n  /**\n   * Given the path to a debug file, returns the absolute path to its\n   * corresponding build info file if it exists, or undefined otherwise.\n   */\n  private async _getBuildInfoFromDebugFile(\n    debugFilePath: string\n  ): Promise<string | undefined> {\n    if (await fsExtra.pathExists(debugFilePath)) {\n      const { buildInfo } = await fsExtra.readJson(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * Retrieves an artifact for the given `contractName` from the compilation output.\n *\n * @param sourceName The contract's source name.\n * @param contractName the contract's name.\n * @param contractOutput the contract's compilation output as emitted by `solc`.\n */\nexport function getArtifactFromContractOutput(\n  sourceName: string,\n  contractName: string,\n  contractOutput: any\n): Artifact {\n  const evmBytecode = contractOutput.evm && contractOutput.evm.bytecode;\n  let bytecode: string =\n    evmBytecode && evmBytecode.object ? evmBytecode.object : \"\";\n\n  if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    bytecode = `0x${bytecode}`;\n  }\n\n  const evmDeployedBytecode =\n    contractOutput.evm && contractOutput.evm.deployedBytecode;\n  let deployedBytecode: string =\n    evmDeployedBytecode && evmDeployedBytecode.object\n      ? evmDeployedBytecode.object\n      : \"\";\n\n  if (deployedBytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    deployedBytecode = `0x${deployedBytecode}`;\n  }\n\n  const linkReferences =\n    evmBytecode && evmBytecode.linkReferences ? evmBytecode.linkReferences : {};\n  const deployedLinkReferences =\n    evmDeployedBytecode && evmDeployedBytecode.linkReferences\n      ? evmDeployedBytecode.linkReferences\n      : {};\n\n  return {\n    _format: ARTIFACT_FORMAT_VERSION,\n    contractName,\n    sourceName,\n    abi: contractOutput.abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}