{"ast":null,"code":"'use strict';\n\nconst Busboy = require('busboy');\nconst util = require('../core/util');\nconst {\n  ReadableStreamFrom,\n  toUSVString,\n  isBlobLike\n} = require('./util');\nconst {\n  FormData\n} = require('./formdata');\nconst {\n  kState\n} = require('./symbols');\nconst {\n  webidl\n} = require('./webidl');\nconst {\n  DOMException\n} = require('./constants');\nconst {\n  Blob\n} = require('buffer');\nconst {\n  kBodyUsed\n} = require('../core/symbols');\nconst assert = require('assert');\nconst {\n  isErrored\n} = require('../core/util');\nconst {\n  isUint8Array,\n  isArrayBuffer\n} = require('util/types');\nconst {\n  File\n} = require('./file');\nlet ReadableStream;\nasync function* blobGen(blob) {\n  yield* blob.stream();\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody(object) {\n  let keepalive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n\n  // 1. Let stream be object if object is a ReadableStream object.\n  // Otherwise, let stream be a new ReadableStream, and set up stream.\n  let stream = null;\n\n  // 2. Let action be null.\n  let action = null;\n\n  // 3. Let source be null.\n  let source = null;\n\n  // 4. Let length be null.\n  let length = null;\n\n  // 5. Let Content-Type be null.\n  let contentType = null;\n\n  // 6. Switch on object:\n  if (object == null) {\n    // Note: The IDL processor cannot handle this situation. See\n    // https://crbug.com/335871.\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString();\n\n    // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    contentType = 'application/x-www-form-urlencoded;charset=UTF-8';\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice());\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n  } else if (util.isFormDataLike(object)) {\n    const boundary = '----formdata-undici-' + Math.random();\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = str => str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22');\n    const normalizeLinefeeds = value => value.replace(/\\r?\\n|\\r/g, '\\r\\n');\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    action = async function* (object) {\n      const enc = new TextEncoder();\n      for (const [name, value] of object) {\n        if (typeof value === 'string') {\n          yield enc.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n        } else {\n          yield enc.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' + `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`);\n          yield* blobGen(value);\n          yield enc.encode('\\r\\n');\n        }\n      }\n      yield enc.encode(`--${boundary}--`);\n    };\n\n    // Set source to object.\n    source = object;\n\n    // Set length to unclear, see html/6424 for improving this.\n    // TODO\n\n    // Set Content-Type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    contentType = 'multipart/form-data; boundary=' + boundary;\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set action to this step: read object.\n    action = blobGen;\n\n    // Set source to object.\n    source = object;\n\n    // Set length to object’s size.\n    length = object.size;\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // Content-Type to its value.\n    if (object.type) {\n      contentType = object.type;\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive');\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError('Response body object should not be disturbed or locked');\n    }\n    stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n  } else {\n    // TODO: byte sequence?\n    // TODO: scalar value string?\n    // TODO: else?\n    source = toUSVString(object);\n    contentType = 'text/plain;charset=UTF-8';\n  }\n\n  // 7. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  // TODO: What is a \"byte sequence?\"\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source);\n  }\n\n  // 8. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator;\n    stream = new ReadableStream({\n      async start() {\n        iterator = action(object)[Symbol.asyncIterator]();\n      },\n      async pull(controller) {\n        const {\n          value,\n          done\n        } = await iterator.next();\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close();\n          });\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value));\n          }\n        }\n        return controller.desiredSize > 0;\n      },\n      async cancel(reason) {\n        await iterator.return();\n      }\n    });\n  } else if (!stream) {\n    // TODO: Spec doesn't say anything about this?\n    stream = new ReadableStream({\n      async pull(controller) {\n        controller.enqueue(typeof source === 'string' ? new TextEncoder().encode(source) : source);\n        queueMicrotask(() => {\n          controller.close();\n        });\n      }\n    });\n  }\n\n  // 9. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = {\n    stream,\n    source,\n    length\n  };\n\n  // 10. Return body and Content-Type.\n  return [body, contentType];\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody(object) {\n  let keepalive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.');\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.');\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive);\n}\nfunction cloneBody(body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee();\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1;\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  };\n}\nasync function* consumeBody(body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body;\n    } else {\n      const stream = body.stream;\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('The body has already been consumed.');\n      }\n      if (stream.locked) {\n        throw new TypeError('The stream is locked.');\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true;\n      yield* stream;\n    }\n  }\n}\nfunction throwIfAborted(state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError');\n  }\n}\nfunction bodyMixinMethods(instance) {\n  const methods = {\n    async blob() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n      throwIfAborted(this[kState]);\n      const chunks = [];\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk');\n        }\n\n        // Assemble one final large blob with Uint8Array's can exhaust memory.\n        // That's why we create create multiple blob's and using references\n        chunks.push(new Blob([chunk]));\n      }\n      return new Blob(chunks, {\n        type: this.headers.get('Content-Type') || ''\n      });\n    },\n    async arrayBuffer() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n      throwIfAborted(this[kState]);\n      const contentLength = this.headers.get('content-length');\n      const encoded = this.headers.has('content-encoding');\n\n      // if we have content length and no encoding, then we can\n      // pre allocate the buffer and just read the data into it\n      if (!encoded && contentLength) {\n        const buffer = new Uint8Array(contentLength);\n        let offset = 0;\n        for await (const chunk of consumeBody(this[kState].body)) {\n          if (!isUint8Array(chunk)) {\n            throw new TypeError('Expected Uint8Array chunk');\n          }\n          buffer.set(chunk, offset);\n          offset += chunk.length;\n        }\n        return buffer.buffer;\n      }\n\n      // if we don't have content length, then we have to allocate 2x the\n      // size of the body, once for consumed data, and once for the final buffer\n\n      // This could be optimized by using growable ArrayBuffer, but it's not\n      // implemented yet. https://github.com/tc39/proposal-resizablearraybuffer\n\n      const chunks = [];\n      let size = 0;\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk');\n        }\n        chunks.push(chunk);\n        size += chunk.byteLength;\n      }\n      const buffer = new Uint8Array(size);\n      let offset = 0;\n      for (const chunk of chunks) {\n        buffer.set(chunk, offset);\n        offset += chunk.byteLength;\n      }\n      return buffer.buffer;\n    },\n    async text() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n      throwIfAborted(this[kState]);\n      let result = '';\n      const textDecoder = new TextDecoder();\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk');\n        }\n        result += textDecoder.decode(chunk, {\n          stream: true\n        });\n      }\n\n      // flush\n      result += textDecoder.decode();\n      return result;\n    },\n    async json() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n      throwIfAborted(this[kState]);\n      return JSON.parse(await this.text());\n    },\n    async formData() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n      throwIfAborted(this[kState]);\n      const contentType = this.headers.get('Content-Type');\n\n      // If mimeType’s essence is \"multipart/form-data\", then:\n      if (/multipart\\/form-data/.test(contentType)) {\n        const headers = {};\n        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;\n        const responseFormData = new FormData();\n        let busboy;\n        try {\n          busboy = Busboy({\n            headers\n          });\n        } catch (err) {\n          // Error due to headers:\n          throw Object.assign(new TypeError(), {\n            cause: err\n          });\n        }\n        busboy.on('field', (name, value) => {\n          responseFormData.append(name, value);\n        });\n        busboy.on('file', (name, value, info) => {\n          const {\n            filename,\n            encoding,\n            mimeType\n          } = info;\n          const chunks = [];\n          if (encoding.toLowerCase() === 'base64') {\n            let base64chunk = '';\n            value.on('data', chunk => {\n              base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '');\n              const end = base64chunk.length - base64chunk.length % 4;\n              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'));\n              base64chunk = base64chunk.slice(end);\n            });\n            value.on('end', () => {\n              chunks.push(Buffer.from(base64chunk, 'base64'));\n              responseFormData.append(name, new File(chunks, filename, {\n                type: mimeType\n              }));\n            });\n          } else {\n            value.on('data', chunk => {\n              chunks.push(chunk);\n            });\n            value.on('end', () => {\n              responseFormData.append(name, new File(chunks, filename, {\n                type: mimeType\n              }));\n            });\n          }\n        });\n        const busboyResolve = new Promise((resolve, reject) => {\n          busboy.on('finish', resolve);\n          busboy.on('error', err => reject(err));\n        });\n        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);\n        busboy.end();\n        await busboyResolve;\n        return responseFormData;\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n        // 1. Let entries be the result of parsing bytes.\n        let entries;\n        try {\n          let text = '';\n          // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n          const textDecoder = new TextDecoder('utf-8', {\n            ignoreBOM: true\n          });\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk');\n            }\n            text += textDecoder.decode(chunk, {\n              stream: true\n            });\n          }\n          text += textDecoder.decode();\n          entries = new URLSearchParams(text);\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), {\n            cause: err\n          });\n        }\n\n        // 3. Return a new FormData object whose entries are entries.\n        const formData = new FormData();\n        for (const [name, value] of entries) {\n          formData.append(name, value);\n        }\n        return formData;\n      } else {\n        // Wait a tick before checking if the request has been aborted.\n        // Otherwise, a TypeError can be thrown when an AbortError should.\n        await Promise.resolve();\n        throwIfAborted(this[kState]);\n\n        // Otherwise, throw a TypeError.\n        webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          message: 'Could not parse content as FormData.'\n        });\n      }\n    }\n  };\n  return methods;\n}\nconst properties = {\n  body: {\n    enumerable: true,\n    get() {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation');\n      }\n      return this[kState].body ? this[kState].body.stream : null;\n    }\n  },\n  bodyUsed: {\n    enumerable: true,\n    get() {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation');\n      }\n      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n  }\n};\nfunction mixinBody(prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n  Object.defineProperties(prototype.prototype, properties);\n}\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n};","map":{"version":3,"names":["Busboy","require","util","ReadableStreamFrom","toUSVString","isBlobLike","FormData","kState","webidl","DOMException","Blob","kBodyUsed","assert","isErrored","isUint8Array","isArrayBuffer","File","ReadableStream","blobGen","blob","stream","extractBody","object","keepalive","action","source","length","contentType","URLSearchParams","toString","Uint8Array","slice","ArrayBuffer","isView","buffer","byteOffset","byteLength","isFormDataLike","boundary","Math","random","prefix","escape","str","replace","normalizeLinefeeds","value","enc","TextEncoder","name","encode","type","size","Symbol","asyncIterator","TypeError","isDisturbed","locked","isBuffer","Buffer","iterator","start","pull","controller","done","next","queueMicrotask","close","enqueue","desiredSize","cancel","reason","return","body","safelyExtractBody","cloneBody","out1","out2","tee","consumeBody","throwIfAborted","state","aborted","bodyMixinMethods","instance","methods","chunks","chunk","push","headers","get","arrayBuffer","contentLength","encoded","has","offset","set","text","result","textDecoder","TextDecoder","decode","json","JSON","parse","formData","test","key","toLowerCase","responseFormData","busboy","err","Object","assign","cause","on","append","info","filename","encoding","mimeType","base64chunk","end","from","busboyResolve","Promise","resolve","reject","write","entries","ignoreBOM","errors","exception","header","message","properties","enumerable","bodyUsed","mixinBody","prototype","defineProperties","module","exports"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/undici/lib/fetch/body.js"],"sourcesContent":["'use strict'\n\nconst Busboy = require('busboy')\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString, isBlobLike } = require('./util')\nconst { FormData } = require('./formdata')\nconst { kState } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { DOMException } = require('./constants')\nconst { Blob } = require('buffer')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('assert')\nconst { isErrored } = require('../core/util')\nconst { isUint8Array, isArrayBuffer } = require('util/types')\nconst { File } = require('./file')\n\nlet ReadableStream\n\nasync function * blobGen (blob) {\n  yield * blob.stream()\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // 1. Let stream be object if object is a ReadableStream object.\n  // Otherwise, let stream be a new ReadableStream, and set up stream.\n  let stream = null\n\n  // 2. Let action be null.\n  let action = null\n\n  // 3. Let source be null.\n  let source = null\n\n  // 4. Let length be null.\n  let length = null\n\n  // 5. Let Content-Type be null.\n  let contentType = null\n\n  // 6. Switch on object:\n  if (object == null) {\n    // Note: The IDL processor cannot handle this situation. See\n    // https://crbug.com/335871.\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    contentType = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = '----formdata-undici-' + Math.random()\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    action = async function * (object) {\n      const enc = new TextEncoder()\n\n      for (const [name, value] of object) {\n        if (typeof value === 'string') {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`\n          )\n        } else {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              (value.name ? `; filename=\"${escape(value.name)}\"` : '') +\n              '\\r\\n' +\n              `Content-Type: ${\n                value.type || 'application/octet-stream'\n              }\\r\\n\\r\\n`\n          )\n\n          yield * blobGen(value)\n\n          yield enc.encode('\\r\\n')\n        }\n      }\n\n      yield enc.encode(`--${boundary}--`)\n    }\n\n    // Set source to object.\n    source = object\n\n    // Set length to unclear, see html/6424 for improving this.\n    // TODO\n\n    // Set Content-Type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    contentType = 'multipart/form-data; boundary=' + boundary\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set action to this step: read object.\n    action = blobGen\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // Content-Type to its value.\n    if (object.type) {\n      contentType = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  } else {\n    // TODO: byte sequence?\n    // TODO: scalar value string?\n    // TODO: else?\n    source = toUSVString(object)\n    contentType = 'text/plain;charset=UTF-8'\n  }\n\n  // 7. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  // TODO: What is a \"byte sequence?\"\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 8. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      }\n    })\n  } else if (!stream) {\n    // TODO: Spec doesn't say anything about this?\n    stream = new ReadableStream({\n      async pull (controller) {\n        controller.enqueue(\n          typeof source === 'string' ? new TextEncoder().encode(source) : source\n        )\n        queueMicrotask(() => {\n          controller.close()\n        })\n      }\n    })\n  }\n\n  // 9. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 10. Return body and Content-Type.\n  return [body, contentType]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nasync function * consumeBody (body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body\n    } else {\n      const stream = body.stream\n\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('The body has already been consumed.')\n      }\n\n      if (stream.locked) {\n        throw new TypeError('The stream is locked.')\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true\n\n      yield * stream\n    }\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    async blob () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      throwIfAborted(this[kState])\n\n      const chunks = []\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk')\n        }\n\n        // Assemble one final large blob with Uint8Array's can exhaust memory.\n        // That's why we create create multiple blob's and using references\n        chunks.push(new Blob([chunk]))\n      }\n\n      return new Blob(chunks, { type: this.headers.get('Content-Type') || '' })\n    },\n\n    async arrayBuffer () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      throwIfAborted(this[kState])\n\n      const contentLength = this.headers.get('content-length')\n      const encoded = this.headers.has('content-encoding')\n\n      // if we have content length and no encoding, then we can\n      // pre allocate the buffer and just read the data into it\n      if (!encoded && contentLength) {\n        const buffer = new Uint8Array(contentLength)\n        let offset = 0\n\n        for await (const chunk of consumeBody(this[kState].body)) {\n          if (!isUint8Array(chunk)) {\n            throw new TypeError('Expected Uint8Array chunk')\n          }\n\n          buffer.set(chunk, offset)\n          offset += chunk.length\n        }\n\n        return buffer.buffer\n      }\n\n      // if we don't have content length, then we have to allocate 2x the\n      // size of the body, once for consumed data, and once for the final buffer\n\n      // This could be optimized by using growable ArrayBuffer, but it's not\n      // implemented yet. https://github.com/tc39/proposal-resizablearraybuffer\n\n      const chunks = []\n      let size = 0\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk')\n        }\n\n        chunks.push(chunk)\n        size += chunk.byteLength\n      }\n\n      const buffer = new Uint8Array(size)\n      let offset = 0\n\n      for (const chunk of chunks) {\n        buffer.set(chunk, offset)\n        offset += chunk.byteLength\n      }\n\n      return buffer.buffer\n    },\n\n    async text () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      throwIfAborted(this[kState])\n\n      let result = ''\n      const textDecoder = new TextDecoder()\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk')\n        }\n\n        result += textDecoder.decode(chunk, { stream: true })\n      }\n\n      // flush\n      result += textDecoder.decode()\n\n      return result\n    },\n\n    async json () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      throwIfAborted(this[kState])\n\n      return JSON.parse(await this.text())\n    },\n\n    async formData () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      throwIfAborted(this[kState])\n\n      const contentType = this.headers.get('Content-Type')\n\n      // If mimeType’s essence is \"multipart/form-data\", then:\n      if (/multipart\\/form-data/.test(contentType)) {\n        const headers = {}\n        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value\n\n        const responseFormData = new FormData()\n\n        let busboy\n\n        try {\n          busboy = Busboy({ headers })\n        } catch (err) {\n          // Error due to headers:\n          throw Object.assign(new TypeError(), { cause: err })\n        }\n\n        busboy.on('field', (name, value) => {\n          responseFormData.append(name, value)\n        })\n        busboy.on('file', (name, value, info) => {\n          const { filename, encoding, mimeType } = info\n          const chunks = []\n\n          if (encoding.toLowerCase() === 'base64') {\n            let base64chunk = ''\n\n            value.on('data', (chunk) => {\n              base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '')\n\n              const end = base64chunk.length - base64chunk.length % 4\n              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'))\n\n              base64chunk = base64chunk.slice(end)\n            })\n            value.on('end', () => {\n              chunks.push(Buffer.from(base64chunk, 'base64'))\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          } else {\n            value.on('data', (chunk) => {\n              chunks.push(chunk)\n            })\n            value.on('end', () => {\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          }\n        })\n\n        const busboyResolve = new Promise((resolve, reject) => {\n          busboy.on('finish', resolve)\n          busboy.on('error', (err) => reject(err))\n        })\n\n        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk)\n        busboy.end()\n        await busboyResolve\n\n        return responseFormData\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n        // 1. Let entries be the result of parsing bytes.\n        let entries\n        try {\n          let text = ''\n          // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n          const textDecoder = new TextDecoder('utf-8', { ignoreBOM: true })\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk')\n            }\n            text += textDecoder.decode(chunk, { stream: true })\n          }\n          text += textDecoder.decode()\n          entries = new URLSearchParams(text)\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), { cause: err })\n        }\n\n        // 3. Return a new FormData object whose entries are entries.\n        const formData = new FormData()\n        for (const [name, value] of entries) {\n          formData.append(name, value)\n        }\n        return formData\n      } else {\n        // Wait a tick before checking if the request has been aborted.\n        // Otherwise, a TypeError can be thrown when an AbortError should.\n        await Promise.resolve()\n\n        throwIfAborted(this[kState])\n\n        // Otherwise, throw a TypeError.\n        webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          message: 'Could not parse content as FormData.'\n        })\n      }\n    }\n  }\n\n  return methods\n}\n\nconst properties = {\n  body: {\n    enumerable: true,\n    get () {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      return this[kState].body ? this[kState].body.stream : null\n    }\n  },\n  bodyUsed: {\n    enumerable: true,\n    get () {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n    }\n  }\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n  Object.defineProperties(prototype.prototype, properties)\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}