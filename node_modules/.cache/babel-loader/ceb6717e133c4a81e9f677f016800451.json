{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyProviderWrappers = exports.createProvider = exports.isHDAccountsConfig = void 0;\nconst constants_1 = require(\"../../constants\");\nconst date_1 = require(\"../../util/date\");\nconst util_1 = require(\"./util\");\nfunction isHDAccountsConfig(accounts) {\n  return accounts !== undefined && Object.keys(accounts).includes(\"mnemonic\");\n}\nexports.isHDAccountsConfig = isHDAccountsConfig;\nfunction isResolvedHttpNetworkConfig(netConfig) {\n  return \"url\" in netConfig;\n}\n// This function is let's you import a provider dynamically in a pretty\n// type-safe way.\n// `ProviderNameT` and `name` must be the same literal string. TS enforces it.\n// `ModuleT` and `filePath` must also be the same, but this is not enforced.\nfunction importProvider(filePath, name) {\n  const mod = require(filePath);\n  return mod[name];\n}\nfunction createProvider(networkName, networkConfig, paths, artifacts) {\n  let experimentalHardhatNetworkMessageTraceHooks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  let eip1193Provider;\n  if (networkName === constants_1.HARDHAT_NETWORK_NAME) {\n    const hardhatNetConfig = networkConfig;\n    const HardhatNetworkProvider = importProvider(\"../../hardhat-network/provider/provider\", \"HardhatNetworkProvider\");\n    let forkConfig;\n    if (hardhatNetConfig.forking?.enabled === true && hardhatNetConfig.forking?.url !== undefined) {\n      forkConfig = {\n        jsonRpcUrl: hardhatNetConfig.forking?.url,\n        blockNumber: hardhatNetConfig.forking?.blockNumber,\n        httpHeaders: hardhatNetConfig.forking.httpHeaders\n      };\n    }\n    const accounts = (0, util_1.normalizeHardhatNetworkAccountsConfig)(hardhatNetConfig.accounts);\n    const {\n      ModulesLogger\n    } = require(\"../../hardhat-network/provider/modules/logger\");\n    const {\n      getForkCacheDirPath\n    } = require(\"../../hardhat-network/provider/utils/disk-cache\");\n    eip1193Provider = new HardhatNetworkProvider(hardhatNetConfig.hardfork, constants_1.HARDHAT_NETWORK_NAME, hardhatNetConfig.chainId, hardhatNetConfig.chainId, hardhatNetConfig.blockGasLimit, hardhatNetConfig.initialBaseFeePerGas, hardhatNetConfig.minGasPrice, hardhatNetConfig.throwOnTransactionFailures, hardhatNetConfig.throwOnCallFailures, hardhatNetConfig.mining.auto, hardhatNetConfig.mining.interval,\n    // This cast is valid because of the config validation and resolution\n    hardhatNetConfig.mining.mempool.order, hardhatNetConfig.chains, new ModulesLogger(hardhatNetConfig.loggingEnabled), accounts, artifacts, hardhatNetConfig.allowUnlimitedContractSize, hardhatNetConfig.initialDate !== undefined ? (0, date_1.parseDateString)(hardhatNetConfig.initialDate) : undefined, experimentalHardhatNetworkMessageTraceHooks, forkConfig, paths !== undefined ? getForkCacheDirPath(paths) : undefined, hardhatNetConfig.coinbase);\n  } else {\n    const HttpProvider = importProvider(\"./http\", \"HttpProvider\");\n    const httpNetConfig = networkConfig;\n    eip1193Provider = new HttpProvider(httpNetConfig.url, networkName, httpNetConfig.httpHeaders, httpNetConfig.timeout);\n  }\n  const wrappedProvider = applyProviderWrappers(eip1193Provider, networkConfig);\n  const BackwardsCompatibilityProviderAdapter = importProvider(\"./backwards-compatibility\", \"BackwardsCompatibilityProviderAdapter\");\n  return new BackwardsCompatibilityProviderAdapter(wrappedProvider);\n}\nexports.createProvider = createProvider;\nfunction applyProviderWrappers(provider, netConfig) {\n  // These dependencies are lazy-loaded because they are really big.\n  const LocalAccountsProvider = importProvider(\"./accounts\", \"LocalAccountsProvider\");\n  const HDWalletProvider = importProvider(\"./accounts\", \"HDWalletProvider\");\n  const FixedSenderProvider = importProvider(\"./accounts\", \"FixedSenderProvider\");\n  const AutomaticSenderProvider = importProvider(\"./accounts\", \"AutomaticSenderProvider\");\n  const AutomaticGasProvider = importProvider(\"./gas-providers\", \"AutomaticGasProvider\");\n  const FixedGasProvider = importProvider(\"./gas-providers\", \"FixedGasProvider\");\n  const AutomaticGasPriceProvider = importProvider(\"./gas-providers\", \"AutomaticGasPriceProvider\");\n  const FixedGasPriceProvider = importProvider(\"./gas-providers\", \"FixedGasPriceProvider\");\n  const ChainIdValidatorProvider = importProvider(\"./chainId\", \"ChainIdValidatorProvider\");\n  if (isResolvedHttpNetworkConfig(netConfig)) {\n    const accounts = netConfig.accounts;\n    if (Array.isArray(accounts)) {\n      provider = new LocalAccountsProvider(provider, accounts);\n    } else if (isHDAccountsConfig(accounts)) {\n      provider = new HDWalletProvider(provider, accounts.mnemonic, accounts.path, accounts.initialIndex, accounts.count, accounts.passphrase);\n    }\n    // TODO: Add some extension mechanism for account plugins here\n  }\n\n  if (netConfig.from !== undefined) {\n    provider = new FixedSenderProvider(provider, netConfig.from);\n  } else {\n    provider = new AutomaticSenderProvider(provider);\n  }\n  if (netConfig.gas === undefined || netConfig.gas === \"auto\") {\n    provider = new AutomaticGasProvider(provider, netConfig.gasMultiplier);\n  } else {\n    provider = new FixedGasProvider(provider, netConfig.gas);\n  }\n  if (netConfig.gasPrice === undefined || netConfig.gasPrice === \"auto\") {\n    // If you use a LocalAccountsProvider or HDWalletProvider, your transactions\n    // are signed locally. This requires having all of their fields available,\n    // including the gasPrice / maxFeePerGas & maxPriorityFeePerGas.\n    //\n    // We never use those providers when using Hardhat Network, but sign within\n    // Hardhat Network itself. This means that we don't need to provide all the\n    // fields, as the missing ones will be resolved there.\n    //\n    // Hardhat Network handles this in a more performant way, so we don't use\n    // the AutomaticGasPriceProvider for it.\n    if (isResolvedHttpNetworkConfig(netConfig)) {\n      provider = new AutomaticGasPriceProvider(provider);\n    }\n  } else {\n    provider = new FixedGasPriceProvider(provider, netConfig.gasPrice);\n  }\n  if (isResolvedHttpNetworkConfig(netConfig) && netConfig.chainId !== undefined) {\n    provider = new ChainIdValidatorProvider(provider, netConfig.chainId);\n  }\n  return provider;\n}\nexports.applyProviderWrappers = applyProviderWrappers;","map":{"version":3,"mappings":";;;;;;AAmBA;AACA;AAEA;AAEA,SAAgBA,kBAAkB,CAChCC,QAAwC;EAExC,OAAOA,QAAQ,KAAKC,SAAS,IAAIC,MAAM,CAACC,IAAI,CAACH,QAAQ,CAAC,CAACI,QAAQ,CAAC,UAAU,CAAC;AAC7E;AAJAC;AAMA,SAASC,2BAA2B,CAClCC,SAAiC;EAEjC,OAAO,KAAK,IAAIA,SAAS;AAC3B;AAEA;AACA;AACA;AACA;AACA,SAASC,cAAc,CACrBC,QAAgB,EAChBC,IAAmB;EAEnB,MAAMC,GAAG,GAAGC,OAAO,CAACH,QAAQ,CAAC;EAC7B,OAAOE,GAAG,CAACD,IAAI,CAAC;AAClB;AAEA,SAAgBG,cAAc,CAC5BC,WAAmB,EACnBC,aAA4B,EAC5BC,KAA0B,EAC1BC,SAAqB,EAC8E;EAAA,IAAnGC,kHAAiG,EAAE;EAEnG,IAAIC,eAAgC;EAEpC,IAAIL,WAAW,KAAKM,gCAAoB,EAAE;IACxC,MAAMC,gBAAgB,GAAGN,aAAqC;IAE9D,MAAMO,sBAAsB,GAAGd,cAAc,CAG3C,yCAAyC,EAAE,wBAAwB,CAAC;IAEtE,IAAIe,UAAkC;IAEtC,IACEF,gBAAgB,CAACG,OAAO,EAAEC,OAAO,KAAK,IAAI,IAC1CJ,gBAAgB,CAACG,OAAO,EAAEE,GAAG,KAAKzB,SAAS,EAC3C;MACAsB,UAAU,GAAG;QACXI,UAAU,EAAEN,gBAAgB,CAACG,OAAO,EAAEE,GAAG;QACzCE,WAAW,EAAEP,gBAAgB,CAACG,OAAO,EAAEI,WAAW;QAClDC,WAAW,EAAER,gBAAgB,CAACG,OAAO,CAACK;OACvC;;IAGH,MAAM7B,QAAQ,GAAG,gDAAqC,EACpDqB,gBAAgB,CAACrB,QAAQ,CAC1B;IAED,MAAM;MAAE8B;IAAa,CAAE,GACrBlB,OAAO,CAAC,+CAA+C,CAA0B;IACnF,MAAM;MAAEmB;IAAmB,CAAE,GAC3BnB,OAAO,CAAC,iDAAiD,CAAsB;IAEjFO,eAAe,GAAG,IAAIG,sBAAsB,CAC1CD,gBAAgB,CAACW,QAAQ,EACzBZ,gCAAoB,EACpBC,gBAAgB,CAACY,OAAO,EACxBZ,gBAAgB,CAACY,OAAO,EACxBZ,gBAAgB,CAACa,aAAa,EAC9Bb,gBAAgB,CAACc,oBAAoB,EACrCd,gBAAgB,CAACe,WAAW,EAC5Bf,gBAAgB,CAACgB,0BAA0B,EAC3ChB,gBAAgB,CAACiB,mBAAmB,EACpCjB,gBAAgB,CAACkB,MAAM,CAACC,IAAI,EAC5BnB,gBAAgB,CAACkB,MAAM,CAACE,QAAQ;IAChC;IACApB,gBAAgB,CAACkB,MAAM,CAACG,OAAO,CAACC,KAAqB,EACrDtB,gBAAgB,CAACuB,MAAM,EACvB,IAAId,aAAa,CAACT,gBAAgB,CAACwB,cAAc,CAAC,EAClD7C,QAAQ,EACRiB,SAAS,EACTI,gBAAgB,CAACyB,0BAA0B,EAC3CzB,gBAAgB,CAAC0B,WAAW,KAAK9C,SAAS,GACtC,0BAAe,EAACoB,gBAAgB,CAAC0B,WAAW,CAAC,GAC7C9C,SAAS,EACbiB,2CAA2C,EAC3CK,UAAU,EACVP,KAAK,KAAKf,SAAS,GAAG8B,mBAAmB,CAACf,KAAK,CAAC,GAAGf,SAAS,EAC5DoB,gBAAgB,CAAC2B,QAAQ,CAC1B;GACF,MAAM;IACL,MAAMC,YAAY,GAAGzC,cAAc,CAGjC,QAAQ,EAAE,cAAc,CAAC;IAC3B,MAAM0C,aAAa,GAAGnC,aAAkC;IAExDI,eAAe,GAAG,IAAI8B,YAAY,CAChCC,aAAa,CAACxB,GAAI,EAClBZ,WAAW,EACXoC,aAAa,CAACrB,WAAW,EACzBqB,aAAa,CAACC,OAAO,CACtB;;EAGH,MAAMC,eAAe,GAAGC,qBAAqB,CAAClC,eAAe,EAAEJ,aAAa,CAAC;EAE7E,MAAMuC,qCAAqC,GAAG9C,cAAc,CAG1D,2BAA2B,EAAE,uCAAuC,CAAC;EAEvE,OAAO,IAAI8C,qCAAqC,CAACF,eAAe,CAAC;AACnE;AAzFA/C;AA2FA,SAAgBgD,qBAAqB,CACnCE,QAAyB,EACzBhD,SAAiC;EAEjC;EACA,MAAMiD,qBAAqB,GAAGhD,cAAc,CAG1C,YAAY,EAAE,uBAAuB,CAAC;EACxC,MAAMiD,gBAAgB,GAAGjD,cAAc,CAGrC,YAAY,EAAE,kBAAkB,CAAC;EACnC,MAAMkD,mBAAmB,GAAGlD,cAAc,CAGxC,YAAY,EAAE,qBAAqB,CAAC;EACtC,MAAMmD,uBAAuB,GAAGnD,cAAc,CAG5C,YAAY,EAAE,yBAAyB,CAAC;EAE1C,MAAMoD,oBAAoB,GAAGpD,cAAc,CAGzC,iBAAiB,EAAE,sBAAsB,CAAC;EAC5C,MAAMqD,gBAAgB,GAAGrD,cAAc,CAGrC,iBAAiB,EAAE,kBAAkB,CAAC;EACxC,MAAMsD,yBAAyB,GAAGtD,cAAc,CAG9C,iBAAiB,EAAE,2BAA2B,CAAC;EACjD,MAAMuD,qBAAqB,GAAGvD,cAAc,CAG1C,iBAAiB,EAAE,uBAAuB,CAAC;EAC7C,MAAMwD,wBAAwB,GAAGxD,cAAc,CAG7C,WAAW,EAAE,0BAA0B,CAAC;EAE1C,IAAIF,2BAA2B,CAACC,SAAS,CAAC,EAAE;IAC1C,MAAMP,QAAQ,GAAGO,SAAS,CAACP,QAAQ;IAEnC,IAAIiE,KAAK,CAACC,OAAO,CAAClE,QAAQ,CAAC,EAAE;MAC3BuD,QAAQ,GAAG,IAAIC,qBAAqB,CAACD,QAAQ,EAAEvD,QAAQ,CAAC;KACzD,MAAM,IAAID,kBAAkB,CAACC,QAAQ,CAAC,EAAE;MACvCuD,QAAQ,GAAG,IAAIE,gBAAgB,CAC7BF,QAAQ,EACRvD,QAAQ,CAACmE,QAAQ,EACjBnE,QAAQ,CAACoE,IAAI,EACbpE,QAAQ,CAACqE,YAAY,EACrBrE,QAAQ,CAACsE,KAAK,EACdtE,QAAQ,CAACuE,UAAU,CACpB;;IAGH;;;EAGF,IAAIhE,SAAS,CAACiE,IAAI,KAAKvE,SAAS,EAAE;IAChCsD,QAAQ,GAAG,IAAIG,mBAAmB,CAACH,QAAQ,EAAEhD,SAAS,CAACiE,IAAI,CAAC;GAC7D,MAAM;IACLjB,QAAQ,GAAG,IAAII,uBAAuB,CAACJ,QAAQ,CAAC;;EAGlD,IAAIhD,SAAS,CAACkE,GAAG,KAAKxE,SAAS,IAAIM,SAAS,CAACkE,GAAG,KAAK,MAAM,EAAE;IAC3DlB,QAAQ,GAAG,IAAIK,oBAAoB,CAACL,QAAQ,EAAEhD,SAAS,CAACmE,aAAa,CAAC;GACvE,MAAM;IACLnB,QAAQ,GAAG,IAAIM,gBAAgB,CAACN,QAAQ,EAAEhD,SAAS,CAACkE,GAAG,CAAC;;EAG1D,IAAIlE,SAAS,CAACoE,QAAQ,KAAK1E,SAAS,IAAIM,SAAS,CAACoE,QAAQ,KAAK,MAAM,EAAE;IACrE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIrE,2BAA2B,CAACC,SAAS,CAAC,EAAE;MAC1CgD,QAAQ,GAAG,IAAIO,yBAAyB,CAACP,QAAQ,CAAC;;GAErD,MAAM;IACLA,QAAQ,GAAG,IAAIQ,qBAAqB,CAACR,QAAQ,EAAEhD,SAAS,CAACoE,QAAQ,CAAC;;EAGpE,IACErE,2BAA2B,CAACC,SAAS,CAAC,IACtCA,SAAS,CAAC0B,OAAO,KAAKhC,SAAS,EAC/B;IACAsD,QAAQ,GAAG,IAAIS,wBAAwB,CAACT,QAAQ,EAAEhD,SAAS,CAAC0B,OAAO,CAAC;;EAGtE,OAAOsB,QAAQ;AACjB;AApGAlD","names":["isHDAccountsConfig","accounts","undefined","Object","keys","includes","exports","isResolvedHttpNetworkConfig","netConfig","importProvider","filePath","name","mod","require","createProvider","networkName","networkConfig","paths","artifacts","experimentalHardhatNetworkMessageTraceHooks","eip1193Provider","constants_1","hardhatNetConfig","HardhatNetworkProvider","forkConfig","forking","enabled","url","jsonRpcUrl","blockNumber","httpHeaders","ModulesLogger","getForkCacheDirPath","hardfork","chainId","blockGasLimit","initialBaseFeePerGas","minGasPrice","throwOnTransactionFailures","throwOnCallFailures","mining","auto","interval","mempool","order","chains","loggingEnabled","allowUnlimitedContractSize","initialDate","coinbase","HttpProvider","httpNetConfig","timeout","wrappedProvider","applyProviderWrappers","BackwardsCompatibilityProviderAdapter","provider","LocalAccountsProvider","HDWalletProvider","FixedSenderProvider","AutomaticSenderProvider","AutomaticGasProvider","FixedGasProvider","AutomaticGasPriceProvider","FixedGasPriceProvider","ChainIdValidatorProvider","Array","isArray","mnemonic","path","initialIndex","count","passphrase","from","gas","gasMultiplier","gasPrice"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/hardhat/src/internal/core/providers/construction.ts"],"sourcesContent":["import type {\n  Artifacts,\n  BoundExperimentalHardhatNetworkMessageTraceHook,\n  EIP1193Provider,\n  EthereumProvider,\n  HardhatNetworkConfig,\n  HDAccountsUserConfig,\n  HttpNetworkAccountsUserConfig,\n  HttpNetworkConfig,\n  NetworkConfig,\n  ProjectPathsConfig,\n} from \"../../../types\";\n\nimport type {\n  ForkConfig,\n  MempoolOrder,\n} from \"../../hardhat-network/provider/node-types\";\nimport type * as ModulesLoggerT from \"../../hardhat-network/provider/modules/logger\";\nimport type * as DiskCacheT from \"../../hardhat-network/provider/utils/disk-cache\";\nimport { HARDHAT_NETWORK_NAME } from \"../../constants\";\nimport { parseDateString } from \"../../util/date\";\n\nimport { normalizeHardhatNetworkAccountsConfig } from \"./util\";\n\nexport function isHDAccountsConfig(\n  accounts?: HttpNetworkAccountsUserConfig\n): accounts is HDAccountsUserConfig {\n  return accounts !== undefined && Object.keys(accounts).includes(\"mnemonic\");\n}\n\nfunction isResolvedHttpNetworkConfig(\n  netConfig: Partial<NetworkConfig>\n): netConfig is HttpNetworkConfig {\n  return \"url\" in netConfig;\n}\n\n// This function is let's you import a provider dynamically in a pretty\n// type-safe way.\n// `ProviderNameT` and `name` must be the same literal string. TS enforces it.\n// `ModuleT` and `filePath` must also be the same, but this is not enforced.\nfunction importProvider<ModuleT, ProviderNameT extends keyof ModuleT>(\n  filePath: string,\n  name: ProviderNameT\n): ModuleT[ProviderNameT] {\n  const mod = require(filePath);\n  return mod[name];\n}\n\nexport function createProvider(\n  networkName: string,\n  networkConfig: NetworkConfig,\n  paths?: ProjectPathsConfig,\n  artifacts?: Artifacts,\n  experimentalHardhatNetworkMessageTraceHooks: BoundExperimentalHardhatNetworkMessageTraceHook[] = []\n): EthereumProvider {\n  let eip1193Provider: EIP1193Provider;\n\n  if (networkName === HARDHAT_NETWORK_NAME) {\n    const hardhatNetConfig = networkConfig as HardhatNetworkConfig;\n\n    const HardhatNetworkProvider = importProvider<\n      typeof import(\"../../hardhat-network/provider/provider\"),\n      \"HardhatNetworkProvider\"\n    >(\"../../hardhat-network/provider/provider\", \"HardhatNetworkProvider\");\n\n    let forkConfig: ForkConfig | undefined;\n\n    if (\n      hardhatNetConfig.forking?.enabled === true &&\n      hardhatNetConfig.forking?.url !== undefined\n    ) {\n      forkConfig = {\n        jsonRpcUrl: hardhatNetConfig.forking?.url,\n        blockNumber: hardhatNetConfig.forking?.blockNumber,\n        httpHeaders: hardhatNetConfig.forking.httpHeaders,\n      };\n    }\n\n    const accounts = normalizeHardhatNetworkAccountsConfig(\n      hardhatNetConfig.accounts\n    );\n\n    const { ModulesLogger } =\n      require(\"../../hardhat-network/provider/modules/logger\") as typeof ModulesLoggerT;\n    const { getForkCacheDirPath } =\n      require(\"../../hardhat-network/provider/utils/disk-cache\") as typeof DiskCacheT;\n\n    eip1193Provider = new HardhatNetworkProvider(\n      hardhatNetConfig.hardfork,\n      HARDHAT_NETWORK_NAME,\n      hardhatNetConfig.chainId,\n      hardhatNetConfig.chainId,\n      hardhatNetConfig.blockGasLimit,\n      hardhatNetConfig.initialBaseFeePerGas,\n      hardhatNetConfig.minGasPrice,\n      hardhatNetConfig.throwOnTransactionFailures,\n      hardhatNetConfig.throwOnCallFailures,\n      hardhatNetConfig.mining.auto,\n      hardhatNetConfig.mining.interval,\n      // This cast is valid because of the config validation and resolution\n      hardhatNetConfig.mining.mempool.order as MempoolOrder,\n      hardhatNetConfig.chains,\n      new ModulesLogger(hardhatNetConfig.loggingEnabled),\n      accounts,\n      artifacts,\n      hardhatNetConfig.allowUnlimitedContractSize,\n      hardhatNetConfig.initialDate !== undefined\n        ? parseDateString(hardhatNetConfig.initialDate)\n        : undefined,\n      experimentalHardhatNetworkMessageTraceHooks,\n      forkConfig,\n      paths !== undefined ? getForkCacheDirPath(paths) : undefined,\n      hardhatNetConfig.coinbase\n    );\n  } else {\n    const HttpProvider = importProvider<\n      typeof import(\"./http\"),\n      \"HttpProvider\"\n    >(\"./http\", \"HttpProvider\");\n    const httpNetConfig = networkConfig as HttpNetworkConfig;\n\n    eip1193Provider = new HttpProvider(\n      httpNetConfig.url!,\n      networkName,\n      httpNetConfig.httpHeaders,\n      httpNetConfig.timeout\n    );\n  }\n\n  const wrappedProvider = applyProviderWrappers(eip1193Provider, networkConfig);\n\n  const BackwardsCompatibilityProviderAdapter = importProvider<\n    typeof import(\"./backwards-compatibility\"),\n    \"BackwardsCompatibilityProviderAdapter\"\n  >(\"./backwards-compatibility\", \"BackwardsCompatibilityProviderAdapter\");\n\n  return new BackwardsCompatibilityProviderAdapter(wrappedProvider);\n}\n\nexport function applyProviderWrappers(\n  provider: EIP1193Provider,\n  netConfig: Partial<NetworkConfig>\n): EIP1193Provider {\n  // These dependencies are lazy-loaded because they are really big.\n  const LocalAccountsProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"LocalAccountsProvider\"\n  >(\"./accounts\", \"LocalAccountsProvider\");\n  const HDWalletProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"HDWalletProvider\"\n  >(\"./accounts\", \"HDWalletProvider\");\n  const FixedSenderProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"FixedSenderProvider\"\n  >(\"./accounts\", \"FixedSenderProvider\");\n  const AutomaticSenderProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"AutomaticSenderProvider\"\n  >(\"./accounts\", \"AutomaticSenderProvider\");\n\n  const AutomaticGasProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"AutomaticGasProvider\"\n  >(\"./gas-providers\", \"AutomaticGasProvider\");\n  const FixedGasProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"FixedGasProvider\"\n  >(\"./gas-providers\", \"FixedGasProvider\");\n  const AutomaticGasPriceProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"AutomaticGasPriceProvider\"\n  >(\"./gas-providers\", \"AutomaticGasPriceProvider\");\n  const FixedGasPriceProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"FixedGasPriceProvider\"\n  >(\"./gas-providers\", \"FixedGasPriceProvider\");\n  const ChainIdValidatorProvider = importProvider<\n    typeof import(\"./chainId\"),\n    \"ChainIdValidatorProvider\"\n  >(\"./chainId\", \"ChainIdValidatorProvider\");\n\n  if (isResolvedHttpNetworkConfig(netConfig)) {\n    const accounts = netConfig.accounts;\n\n    if (Array.isArray(accounts)) {\n      provider = new LocalAccountsProvider(provider, accounts);\n    } else if (isHDAccountsConfig(accounts)) {\n      provider = new HDWalletProvider(\n        provider,\n        accounts.mnemonic,\n        accounts.path,\n        accounts.initialIndex,\n        accounts.count,\n        accounts.passphrase\n      );\n    }\n\n    // TODO: Add some extension mechanism for account plugins here\n  }\n\n  if (netConfig.from !== undefined) {\n    provider = new FixedSenderProvider(provider, netConfig.from);\n  } else {\n    provider = new AutomaticSenderProvider(provider);\n  }\n\n  if (netConfig.gas === undefined || netConfig.gas === \"auto\") {\n    provider = new AutomaticGasProvider(provider, netConfig.gasMultiplier);\n  } else {\n    provider = new FixedGasProvider(provider, netConfig.gas);\n  }\n\n  if (netConfig.gasPrice === undefined || netConfig.gasPrice === \"auto\") {\n    // If you use a LocalAccountsProvider or HDWalletProvider, your transactions\n    // are signed locally. This requires having all of their fields available,\n    // including the gasPrice / maxFeePerGas & maxPriorityFeePerGas.\n    //\n    // We never use those providers when using Hardhat Network, but sign within\n    // Hardhat Network itself. This means that we don't need to provide all the\n    // fields, as the missing ones will be resolved there.\n    //\n    // Hardhat Network handles this in a more performant way, so we don't use\n    // the AutomaticGasPriceProvider for it.\n    if (isResolvedHttpNetworkConfig(netConfig)) {\n      provider = new AutomaticGasPriceProvider(provider);\n    }\n  } else {\n    provider = new FixedGasPriceProvider(provider, netConfig.gasPrice);\n  }\n\n  if (\n    isResolvedHttpNetworkConfig(netConfig) &&\n    netConfig.chainId !== undefined\n  ) {\n    provider = new ChainIdValidatorProvider(provider, netConfig.chainId);\n  }\n\n  return provider;\n}\n"]},"metadata":{},"sourceType":"script"}