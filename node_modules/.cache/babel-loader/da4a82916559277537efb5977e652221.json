{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.download = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst packageInfo_1 = require(\"./packageInfo\");\nconst TEMP_FILE_PREFIX = \"tmp-\";\nfunction resolveTempFileName(filePath) {\n  const {\n    dir,\n    ext,\n    name\n  } = path_1.default.parse(filePath);\n  return path_1.default.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`\n  });\n}\nasync function download(url, filePath) {\n  let timeoutMillis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;\n  const {\n    pipeline\n  } = await Promise.resolve().then(() => __importStar(require(\"stream\")));\n  const {\n    getGlobalDispatcher,\n    ProxyAgent,\n    request\n  } = await Promise.resolve().then(() => __importStar(require(\"undici\")));\n  const streamPipeline = util_1.default.promisify(pipeline);\n  function chooseDispatcher() {\n    if (process.env.HTTPS_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTPS_PROXY);\n    }\n    if (process.env.HTTP_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTP_PROXY);\n    }\n    return getGlobalDispatcher();\n  }\n  const hardhatVersion = (0, packageInfo_1.getHardhatVersion)();\n  // Fetch the url\n  const response = await request(url, {\n    dispatcher: chooseDispatcher(),\n    headersTimeout: timeoutMillis,\n    maxRedirections: 10,\n    method: \"GET\",\n    headers: {\n      \"User-Agent\": `hardhat ${hardhatVersion ?? \"(unknown version)\"}`\n    }\n  });\n  if (response.statusCode >= 200 && response.statusCode <= 299) {\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fs_extra_1.default.ensureDir(path_1.default.dirname(filePath));\n    await streamPipeline(response.body, fs_1.default.createWriteStream(tmpFilePath));\n    return fs_extra_1.default.move(tmpFilePath, filePath, {\n      overwrite: true\n    });\n  }\n  // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n  throw new Error(`Failed to download ${url} - ${response.statusCode} received. ${await response.body.text()}`);\n}\nexports.download = download;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAEA;AAEA,MAAMA,gBAAgB,GAAG,MAAM;AAE/B,SAASC,mBAAmB,CAACC,QAAgB;EAC3C,MAAM;IAAEC,GAAG;IAAEC,GAAG;IAAEC;EAAI,CAAE,GAAGC,cAAI,CAACC,KAAK,CAACL,QAAQ,CAAC;EAE/C,OAAOI,cAAI,CAACE,MAAM,CAAC;IACjBL,GAAG;IACHC,GAAG;IACHC,IAAI,EAAE,GAAGL,gBAAgB,GAAGK,IAAI;GACjC,CAAC;AACJ;AAEO,eAAeI,QAAQ,CAC5BC,GAAW,EACXR,QAAgB,EACK;EAAA,IAArBS,aAAa,uEAAG,KAAK;EAErB,MAAM;IAAEC;EAAQ,CAAE,GAAG,wDAAa,QAAQ,GAAC;EAC3C,MAAM;IAAEC,mBAAmB;IAAEC,UAAU;IAAEC;EAAO,CAAE,GAAG,wDAAa,QAAQ,GAAC;EAC3E,MAAMC,cAAc,GAAGC,cAAI,CAACC,SAAS,CAACN,QAAQ,CAAC;EAE/C,SAASO,gBAAgB;IACvB,IAAIC,OAAO,CAACC,GAAG,CAACC,WAAW,KAAKC,SAAS,EAAE;MACzC,OAAO,IAAIT,UAAU,CAACM,OAAO,CAACC,GAAG,CAACC,WAAW,CAAC;;IAGhD,IAAIF,OAAO,CAACC,GAAG,CAACG,UAAU,KAAKD,SAAS,EAAE;MACxC,OAAO,IAAIT,UAAU,CAACM,OAAO,CAACC,GAAG,CAACG,UAAU,CAAC;;IAG/C,OAAOX,mBAAmB,EAAE;EAC9B;EAEA,MAAMY,cAAc,GAAG,mCAAiB,GAAE;EAE1C;EACA,MAAMC,QAAQ,GAAG,MAAMX,OAAO,CAACL,GAAG,EAAE;IAClCiB,UAAU,EAAER,gBAAgB,EAAE;IAC9BS,cAAc,EAAEjB,aAAa;IAC7BkB,eAAe,EAAE,EAAE;IACnBC,MAAM,EAAE,KAAK;IACbC,OAAO,EAAE;MACP,YAAY,EAAE,WAAWN,cAAc,IAAI,mBAAmB;;GAEjE,CAAC;EAEF,IAAIC,QAAQ,CAACM,UAAU,IAAI,GAAG,IAAIN,QAAQ,CAACM,UAAU,IAAI,GAAG,EAAE;IAC5D,MAAMC,WAAW,GAAGhC,mBAAmB,CAACC,QAAQ,CAAC;IACjD,MAAMgC,kBAAO,CAACC,SAAS,CAAC7B,cAAI,CAAC8B,OAAO,CAAClC,QAAQ,CAAC,CAAC;IAE/C,MAAMc,cAAc,CAACU,QAAQ,CAACW,IAAI,EAAEC,YAAE,CAACC,iBAAiB,CAACN,WAAW,CAAC,CAAC;IACtE,OAAOC,kBAAO,CAACM,IAAI,CAACP,WAAW,EAAE/B,QAAQ,EAAE;MAAEuC,SAAS,EAAE;IAAI,CAAE,CAAC;;EAGjE;EACA,MAAM,IAAIC,KAAK,CACb,sBAAsBhC,GAAG,MACvBgB,QAAQ,CAACM,UACX,cAAc,MAAMN,QAAQ,CAACW,IAAI,CAACM,IAAI,EAAE,EAAE,CAC3C;AACH;AAhDAC","names":["TEMP_FILE_PREFIX","resolveTempFileName","filePath","dir","ext","name","path_1","parse","format","download","url","timeoutMillis","pipeline","getGlobalDispatcher","ProxyAgent","request","streamPipeline","util_1","promisify","chooseDispatcher","process","env","HTTPS_PROXY","undefined","HTTP_PROXY","hardhatVersion","response","dispatcher","headersTimeout","maxRedirections","method","headers","statusCode","tmpFilePath","fs_extra_1","ensureDir","dirname","body","fs_1","createWriteStream","move","overwrite","Error","text","exports"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/hardhat/src/internal/util/download.ts"],"sourcesContent":["import fs from \"fs\";\nimport fsExtra from \"fs-extra\";\nimport path from \"path\";\nimport util from \"util\";\n\nimport { getHardhatVersion } from \"./packageInfo\";\n\nconst TEMP_FILE_PREFIX = \"tmp-\";\n\nfunction resolveTempFileName(filePath: string): string {\n  const { dir, ext, name } = path.parse(filePath);\n\n  return path.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`,\n  });\n}\n\nexport async function download(\n  url: string,\n  filePath: string,\n  timeoutMillis = 10000\n) {\n  const { pipeline } = await import(\"stream\");\n  const { getGlobalDispatcher, ProxyAgent, request } = await import(\"undici\");\n  const streamPipeline = util.promisify(pipeline);\n\n  function chooseDispatcher() {\n    if (process.env.HTTPS_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTPS_PROXY);\n    }\n\n    if (process.env.HTTP_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTP_PROXY);\n    }\n\n    return getGlobalDispatcher();\n  }\n\n  const hardhatVersion = getHardhatVersion();\n\n  // Fetch the url\n  const response = await request(url, {\n    dispatcher: chooseDispatcher(),\n    headersTimeout: timeoutMillis,\n    maxRedirections: 10,\n    method: \"GET\",\n    headers: {\n      \"User-Agent\": `hardhat ${hardhatVersion ?? \"(unknown version)\"}`,\n    },\n  });\n\n  if (response.statusCode >= 200 && response.statusCode <= 299) {\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fsExtra.ensureDir(path.dirname(filePath));\n\n    await streamPipeline(response.body, fs.createWriteStream(tmpFilePath));\n    return fsExtra.move(tmpFilePath, filePath, { overwrite: true });\n  }\n\n  // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n  throw new Error(\n    `Failed to download ${url} - ${\n      response.statusCode\n    } received. ${await response.body.text()}`\n  );\n}\n"]},"metadata":{},"sourceType":"script"}