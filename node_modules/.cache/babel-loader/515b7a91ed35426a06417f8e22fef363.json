{"ast":null,"code":"'use strict';\n\nconst net = require('net');\nconst assert = require('assert');\nconst util = require('./util');\nconst {\n  InvalidArgumentError,\n  ConnectTimeoutError\n} = require('./errors');\nlet tls; // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nfunction buildConnector(_ref) {\n  let {\n    maxCachedSessions,\n    socketPath,\n    timeout,\n    ...opts\n  } = _ref;\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');\n  }\n  const options = {\n    path: socketPath,\n    ...opts\n  };\n  const sessionCache = new Map();\n  timeout = timeout == null ? 10e3 : timeout;\n  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;\n  return function connect(_ref2, callback) {\n    let {\n      hostname,\n      host,\n      protocol,\n      port,\n      servername,\n      httpSocket\n    } = _ref2;\n    let socket;\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls');\n      }\n      servername = servername || options.servername || util.getServerName(host) || null;\n      const sessionKey = servername || hostname;\n      const session = sessionCache.get(sessionKey) || null;\n      assert(sessionKey);\n      socket = tls.connect({\n        highWaterMark: 16384,\n        // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        socket: httpSocket,\n        // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      });\n      socket.on('session', function (session) {\n        // cache is disabled\n        if (maxCachedSessions === 0) {\n          return;\n        }\n        if (sessionCache.size >= maxCachedSessions) {\n          // remove the oldest session\n          const {\n            value: oldestKey\n          } = sessionCache.keys().next();\n          sessionCache.delete(oldestKey);\n        }\n        sessionCache.set(sessionKey, session);\n      }).on('error', function (err) {\n        if (sessionKey && err.code !== 'UND_ERR_INFO') {\n          // TODO (fix): Only delete for session related errors.\n          sessionCache.delete(sessionKey);\n        }\n      });\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update');\n      socket = net.connect({\n        highWaterMark: 64 * 1024,\n        // Same as nodejs fs streams.\n        ...options,\n        port: port || 80,\n        host: hostname\n      });\n    }\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);\n    socket.setNoDelay(true).once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n      cancelTimeout();\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(null, this);\n      }\n    }).on('error', function (err) {\n      cancelTimeout();\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(err);\n      }\n    });\n    return socket;\n  };\n}\nfunction setupTimeout(onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {};\n  }\n  let s1 = null;\n  let s2 = null;\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we priotorise socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout());\n      } else {\n        onConnectTimeout();\n      }\n    });\n  }, timeout);\n  return () => {\n    clearTimeout(timeoutId);\n    clearImmediate(s1);\n    clearImmediate(s2);\n  };\n}\nfunction onConnectTimeout(socket) {\n  util.destroy(socket, new ConnectTimeoutError());\n}\nmodule.exports = buildConnector;","map":{"version":3,"names":["net","require","assert","util","InvalidArgumentError","ConnectTimeoutError","tls","buildConnector","maxCachedSessions","socketPath","timeout","opts","Number","isInteger","options","path","sessionCache","Map","connect","callback","hostname","host","protocol","port","servername","httpSocket","socket","getServerName","sessionKey","session","get","highWaterMark","on","size","value","oldestKey","keys","next","delete","set","err","code","cancelTimeout","setupTimeout","onConnectTimeout","setNoDelay","once","cb","s1","s2","timeoutId","setTimeout","setImmediate","process","platform","clearTimeout","clearImmediate","destroy","module","exports"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/undici/lib/core/connect.js"],"sourcesContent":["'use strict'\n\nconst net = require('net')\nconst assert = require('assert')\nconst util = require('./util')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nfunction buildConnector ({ maxCachedSessions, socketPath, timeout, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new Map()\n  timeout = timeout == null ? 10e3 : timeout\n  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions\n\n  return function connect ({ hostname, host, protocol, port, servername, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls')\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        socket: httpSocket, // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // cache is disabled\n          if (maxCachedSessions === 0) {\n            return\n          }\n\n          if (sessionCache.size >= maxCachedSessions) {\n            // remove the oldest session\n            const { value: oldestKey } = sessionCache.keys().next()\n            sessionCache.delete(oldestKey)\n          }\n\n          sessionCache.set(sessionKey, session)\n        })\n        .on('error', function (err) {\n          if (sessionKey && err.code !== 'UND_ERR_INFO') {\n            // TODO (fix): Only delete for session related errors.\n            sessionCache.delete(sessionKey)\n          }\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout)\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction setupTimeout (onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {}\n  }\n\n  let s1 = null\n  let s2 = null\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we priotorise socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout())\n      } else {\n        onConnectTimeout()\n      }\n    })\n  }, timeout)\n  return () => {\n    clearTimeout(timeoutId)\n    clearImmediate(s1)\n    clearImmediate(s2)\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  util.destroy(socket, new ConnectTimeoutError())\n}\n\nmodule.exports = buildConnector\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAME,IAAI,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAC9B,MAAM;EAAEG,oBAAoB;EAAEC;AAAoB,CAAC,GAAGJ,OAAO,CAAC,UAAU,CAAC;AACzE,IAAIK,GAAG,EAAC;;AAER;AACA;AACA;AACA;;AAEA,SAASC,cAAc,OAAuD;EAAA,IAArD;IAAEC,iBAAiB;IAAEC,UAAU;IAAEC,OAAO;IAAE,GAAGC;EAAK,CAAC;EAC1E,IAAIH,iBAAiB,IAAI,IAAI,KAAK,CAACI,MAAM,CAACC,SAAS,CAACL,iBAAiB,CAAC,IAAIA,iBAAiB,GAAG,CAAC,CAAC,EAAE;IAChG,MAAM,IAAIJ,oBAAoB,CAAC,sDAAsD,CAAC;EACxF;EAEA,MAAMU,OAAO,GAAG;IAAEC,IAAI,EAAEN,UAAU;IAAE,GAAGE;EAAK,CAAC;EAC7C,MAAMK,YAAY,GAAG,IAAIC,GAAG,EAAE;EAC9BP,OAAO,GAAGA,OAAO,IAAI,IAAI,GAAG,IAAI,GAAGA,OAAO;EAC1CF,iBAAiB,GAAGA,iBAAiB,IAAI,IAAI,GAAG,GAAG,GAAGA,iBAAiB;EAEvE,OAAO,SAASU,OAAO,QAA8DC,QAAQ,EAAE;IAAA,IAAtE;MAAEC,QAAQ;MAAEC,IAAI;MAAEC,QAAQ;MAAEC,IAAI;MAAEC,UAAU;MAAEC;IAAW,CAAC;IACjF,IAAIC,MAAM;IACV,IAAIJ,QAAQ,KAAK,QAAQ,EAAE;MACzB,IAAI,CAAChB,GAAG,EAAE;QACRA,GAAG,GAAGL,OAAO,CAAC,KAAK,CAAC;MACtB;MACAuB,UAAU,GAAGA,UAAU,IAAIV,OAAO,CAACU,UAAU,IAAIrB,IAAI,CAACwB,aAAa,CAACN,IAAI,CAAC,IAAI,IAAI;MAEjF,MAAMO,UAAU,GAAGJ,UAAU,IAAIJ,QAAQ;MACzC,MAAMS,OAAO,GAAGb,YAAY,CAACc,GAAG,CAACF,UAAU,CAAC,IAAI,IAAI;MAEpD1B,MAAM,CAAC0B,UAAU,CAAC;MAElBF,MAAM,GAAGpB,GAAG,CAACY,OAAO,CAAC;QACnBa,aAAa,EAAE,KAAK;QAAE;QACtB,GAAGjB,OAAO;QACVU,UAAU;QACVK,OAAO;QACPH,MAAM,EAAED,UAAU;QAAE;QACpBF,IAAI,EAAEA,IAAI,IAAI,GAAG;QACjBF,IAAI,EAAED;MACR,CAAC,CAAC;MAEFM,MAAM,CACHM,EAAE,CAAC,SAAS,EAAE,UAAUH,OAAO,EAAE;QAChC;QACA,IAAIrB,iBAAiB,KAAK,CAAC,EAAE;UAC3B;QACF;QAEA,IAAIQ,YAAY,CAACiB,IAAI,IAAIzB,iBAAiB,EAAE;UAC1C;UACA,MAAM;YAAE0B,KAAK,EAAEC;UAAU,CAAC,GAAGnB,YAAY,CAACoB,IAAI,EAAE,CAACC,IAAI,EAAE;UACvDrB,YAAY,CAACsB,MAAM,CAACH,SAAS,CAAC;QAChC;QAEAnB,YAAY,CAACuB,GAAG,CAACX,UAAU,EAAEC,OAAO,CAAC;MACvC,CAAC,CAAC,CACDG,EAAE,CAAC,OAAO,EAAE,UAAUQ,GAAG,EAAE;QAC1B,IAAIZ,UAAU,IAAIY,GAAG,CAACC,IAAI,KAAK,cAAc,EAAE;UAC7C;UACAzB,YAAY,CAACsB,MAAM,CAACV,UAAU,CAAC;QACjC;MACF,CAAC,CAAC;IACN,CAAC,MAAM;MACL1B,MAAM,CAAC,CAACuB,UAAU,EAAE,2CAA2C,CAAC;MAChEC,MAAM,GAAG1B,GAAG,CAACkB,OAAO,CAAC;QACnBa,aAAa,EAAE,EAAE,GAAG,IAAI;QAAE;QAC1B,GAAGjB,OAAO;QACVS,IAAI,EAAEA,IAAI,IAAI,EAAE;QAChBF,IAAI,EAAED;MACR,CAAC,CAAC;IACJ;IAEA,MAAMsB,aAAa,GAAGC,YAAY,CAAC,MAAMC,gBAAgB,CAAClB,MAAM,CAAC,EAAEhB,OAAO,CAAC;IAE3EgB,MAAM,CACHmB,UAAU,CAAC,IAAI,CAAC,CAChBC,IAAI,CAACxB,QAAQ,KAAK,QAAQ,GAAG,eAAe,GAAG,SAAS,EAAE,YAAY;MACrEoB,aAAa,EAAE;MAEf,IAAIvB,QAAQ,EAAE;QACZ,MAAM4B,EAAE,GAAG5B,QAAQ;QACnBA,QAAQ,GAAG,IAAI;QACf4B,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;MAChB;IACF,CAAC,CAAC,CACDf,EAAE,CAAC,OAAO,EAAE,UAAUQ,GAAG,EAAE;MAC1BE,aAAa,EAAE;MAEf,IAAIvB,QAAQ,EAAE;QACZ,MAAM4B,EAAE,GAAG5B,QAAQ;QACnBA,QAAQ,GAAG,IAAI;QACf4B,EAAE,CAACP,GAAG,CAAC;MACT;IACF,CAAC,CAAC;IAEJ,OAAOd,MAAM;EACf,CAAC;AACH;AAEA,SAASiB,YAAY,CAAEC,gBAAgB,EAAElC,OAAO,EAAE;EAChD,IAAI,CAACA,OAAO,EAAE;IACZ,OAAO,MAAM,CAAC,CAAC;EACjB;EAEA,IAAIsC,EAAE,GAAG,IAAI;EACb,IAAIC,EAAE,GAAG,IAAI;EACb,MAAMC,SAAS,GAAGC,UAAU,CAAC,MAAM;IACjC;IACAH,EAAE,GAAGI,YAAY,CAAC,MAAM;MACtB,IAAIC,OAAO,CAACC,QAAQ,KAAK,OAAO,EAAE;QAChC;QACAL,EAAE,GAAGG,YAAY,CAAC,MAAMR,gBAAgB,EAAE,CAAC;MAC7C,CAAC,MAAM;QACLA,gBAAgB,EAAE;MACpB;IACF,CAAC,CAAC;EACJ,CAAC,EAAElC,OAAO,CAAC;EACX,OAAO,MAAM;IACX6C,YAAY,CAACL,SAAS,CAAC;IACvBM,cAAc,CAACR,EAAE,CAAC;IAClBQ,cAAc,CAACP,EAAE,CAAC;EACpB,CAAC;AACH;AAEA,SAASL,gBAAgB,CAAElB,MAAM,EAAE;EACjCvB,IAAI,CAACsD,OAAO,CAAC/B,MAAM,EAAE,IAAIrB,mBAAmB,EAAE,CAAC;AACjD;AAEAqD,MAAM,CAACC,OAAO,GAAGpD,cAAc"},"metadata":{},"sourceType":"script"}