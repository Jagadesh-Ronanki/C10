{"ast":null,"code":"'use strict';\n\nconst {\n  redirectStatus\n} = require('./constants');\nconst {\n  performance\n} = require('perf_hooks');\nconst {\n  isBlobLike,\n  toUSVString,\n  ReadableStreamFrom\n} = require('../core/util');\nconst assert = require('assert');\nconst {\n  isUint8Array\n} = require('util/types');\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto;\ntry {\n  crypto = require('crypto');\n} catch {}\n\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = ['1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79', '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137', '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532', '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723', '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697', '10080'];\nfunction responseURL(response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList;\n  const length = urlList.length;\n  return length === 0 ? null : urlList[length - 1].toString();\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL(response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null;\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location');\n\n  // 3. If location is a value, then set location to the result of parsing\n  // location with response’s URL.\n  location = location ? new URL(location, responseURL(response)) : null;\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment;\n  }\n\n  // 5. Return location.\n  return location;\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL(request) {\n  return request.urlList[request.urlList.length - 1];\n}\nfunction requestBadPort(request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request);\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {\n    return 'blocked';\n  }\n\n  // 3. Return allowed.\n  return 'allowed';\n}\nfunction isErrorLike(object) {\n  return object instanceof Error || object?.constructor?.name === 'Error' || object?.constructor?.name === 'DOMException';\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase(statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i);\n    if (!(c === 0x09 ||\n    // HTAB\n    c >= 0x20 && c <= 0x7e ||\n    // SP / VCHAR\n    c >= 0x80 && c <= 0xff\n    // obs-text\n    )) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isTokenChar(c) {\n  return !(c >= 0x7f || c <= 0x20 || c === '(' || c === ')' || c === '<' || c === '>' || c === '@' || c === ',' || c === ';' || c === ':' || c === '\\\\' || c === '\"' || c === '/' || c === '[' || c === ']' || c === '?' || c === '=' || c === '{' || c === '}');\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken(characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false;\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i);\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\nfunction isValidHeaderName(potentialValue) {\n  if (potentialValue.length === 0) {\n    return false;\n  }\n  for (const char of potentialValue) {\n    if (!isValidHTTPToken(char)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue(potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (potentialValue.startsWith('\\t') || potentialValue.startsWith(' ') || potentialValue.endsWith('\\t') || potentialValue.endsWith(' ')) {\n    return false;\n  }\n  if (potentialValue.includes('\\0') || potentialValue.includes('\\r') || potentialValue.includes('\\n')) {\n    return false;\n  }\n  return true;\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  // TODO:  https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n  const policy = '';\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy;\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck() {\n  // TODO\n  return 'allowed';\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck() {\n  // TODO\n  return 'success';\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck() {\n  // TODO\n  return 'success';\n}\nfunction appendFetchMetadata(httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null;\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode;\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header);\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader(request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin;\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('Origin', serializedOrigin);\n    }\n\n    // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null;\n        break;\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n        break;\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n        break;\n      default:\n      // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('Origin', serializedOrigin);\n    }\n  }\n}\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now();\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo(timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  };\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer() {\n  // TODO\n  return {};\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer() {\n  // TODO\n  return {};\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer(request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy;\n\n  // Return no-referrer when empty or policy says so\n  if (policy == null || policy === '' || policy === 'no-referrer') {\n    return 'no-referrer';\n  }\n\n  // 2. Let environment be the request client\n  const environment = request.client;\n  let referrerSource = null;\n\n  /**\n   * 3, Switch on request’s referrer:\n    \"client\"\n      If environment’s global object is a Window object, then\n        Let document be the associated Document of environment’s global object.\n        If document’s origin is an opaque origin, return no referrer.\n        While document is an iframe srcdoc document,\n        let document be document’s browsing context’s browsing context container’s node document.\n        Let referrerSource be document’s URL.\n       Otherwise, let referrerSource be environment’s creation URL.\n     a URL\n    Let referrerSource be request’s referrer.\n   */\n  if (request.referrer === 'client') {\n    // Not defined in Node but part of the spec\n    if (request.client?.globalObject?.constructor?.name === 'Window') {\n      // eslint-disable-line\n      const origin = environment.globalObject.self?.origin ?? environment.globalObject.location?.origin;\n\n      // If document’s origin is an opaque origin, return no referrer.\n      if (origin == null || origin === 'null') return 'no-referrer';\n\n      // Let referrerSource be document’s URL.\n      referrerSource = new URL(environment.globalObject.location.href);\n    } else {\n      // 3(a)(II) If environment's global object is not Window,\n      // Let referrerSource be environments creationURL\n      if (environment?.globalObject?.location == null) {\n        return 'no-referrer';\n      }\n      referrerSource = new URL(environment.globalObject.location.href);\n    }\n  } else if (request.referrer instanceof URL) {\n    // 3(b) If requests's referrer is a URL instance, then make\n    // referrerSource be requests's referrer.\n    referrerSource = request.referrer;\n  } else {\n    // If referrerSource neither client nor instance of URL\n    // then return \"no-referrer\".\n    return 'no-referrer';\n  }\n  const urlProtocol = referrerSource.protocol;\n\n  // If url's scheme is a local scheme (i.e. one of \"about\", \"data\", \"javascript\", \"file\")\n  // then return \"no-referrer\".\n  if (urlProtocol === 'about:' || urlProtocol === 'data:' || urlProtocol === 'blob:') {\n    return 'no-referrer';\n  }\n  let temp;\n  let referrerOrigin;\n  // 4. Let requests's referrerURL be the result of stripping referrer\n  // source for use as referrer (using util function, without origin only)\n  const referrerUrl = (temp = stripURLForReferrer(referrerSource)).length > 4096\n  // 5. Let referrerOrigin be the result of stripping referrer\n  // source for use as referrer (using util function, with originOnly true)\n  ? referrerOrigin = stripURLForReferrer(referrerSource, true)\n  // 6. If result of seralizing referrerUrl is a string whose length is greater than\n  // 4096, then set referrerURL to referrerOrigin\n  : temp;\n  const areSameOrigin = sameOrigin(request, referrerUrl);\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerUrl) && !isURLPotentiallyTrustworthy(request.url);\n\n  // NOTE: How to treat step 7?\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin':\n      return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n    case 'unsafe-url':\n      return referrerUrl;\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer';\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerUrl : referrerOrigin;\n    case 'strict-origin-when-cross-origin':\n      /**\n         * 1. If the origin of referrerURL and the origin of request’s current URL are the same,\n         * then return referrerURL.\n         * 2. If referrerURL is a potentially trustworthy URL and request’s current URL is not a\n         * potentially trustworthy URL, then return no referrer.\n         * 3. Return referrerOrigin\n      */\n      if (areSameOrigin) return referrerOrigin;\n    // else return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n    case 'strict-origin': // eslint-disable-line\n    /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n    /**\n     * 1. If referrerURL is a potentially trustworthy URL and\n     * request’s current URL is not a potentially trustworthy URL,\n     * then return no referrer.\n     * 2. Return referrerOrigin\n    */\n\n    default:\n      // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin;\n  }\n  function stripURLForReferrer(url) {\n    let originOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const urlObject = new URL(url.href);\n    urlObject.username = '';\n    urlObject.password = '';\n    urlObject.hash = '';\n    return originOnly ? urlObject.origin : urlObject.href;\n  }\n}\nfunction isURLPotentiallyTrustworthy(url) {\n  if (!(url instanceof URL)) {\n    return false;\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true;\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true;\n\n  // If file, return true\n  if (url.protocol === 'file:') return true;\n  return isOriginPotentiallyTrustworthy(url.origin);\n  function isOriginPotentiallyTrustworthy(origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false;\n    const originAsURL = new URL(origin);\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true;\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.') || originAsURL.hostname.endsWith('.localhost')) {\n      return true;\n    }\n\n    // If any other, return false\n    return false;\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch(bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true;\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList);\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true;\n  }\n\n  // 3. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true;\n  }\n\n  // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  // Note: this will only work for SHA- algorithms and it's lazy *at best*.\n  const metadata = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));\n\n  // 5. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo;\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash;\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    // Note: \"applying algorithm to bytes\" converts the result to base64\n    const actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (actualValue === expectedValue) {\n      return true;\n    }\n  }\n\n  // 6. Return false.\n  return false;\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// hash-algo is defined in Content Security Policy 2 Section 4.2\n// base64-value is similary defined there\n// VCHAR is defined https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={1,2}))( +[\\x21-\\x7e]?)?/i;\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata(metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = [];\n\n  // 2. Let empty be equal to true.\n  let empty = true;\n  const supportedHashes = crypto.getHashes();\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false;\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token);\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue;\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo;\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups);\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata';\n  }\n  return result;\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin(A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  // \"opaque origin\" is an internal value we cannot access, ignore.\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true;\n  }\n\n  // 3. Return false.\n  return false;\n}\nfunction createDeferredPromise() {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  return {\n    promise,\n    resolve: res,\n    reject: rej\n  };\n}\nfunction isAborted(fetchParams) {\n  return fetchParams.controller.state === 'aborted';\n}\nfunction isCancelled(fetchParams) {\n  return fetchParams.controller.state === 'aborted' || fetchParams.controller.state === 'terminated';\n}\n\n// https://fetch.spec.whatwg.org/#concept-method-normalize\nfunction normalizeMethod(method) {\n  return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString(value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value);\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable');\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string');\n\n  // 4. Return result.\n  return result;\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\n// https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\nfunction makeIterator(iterator, name) {\n  const i = {\n    next() {\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n      }\n      return iterator.next();\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  };\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype);\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i);\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody(body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let promise be the result of fully reading body as promise\n  //    given body.\n  try {\n    /** @type {Uint8Array[]} */\n    const chunks = [];\n    let length = 0;\n    const reader = body.stream.getReader();\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done === true) {\n        break;\n      }\n\n      // read-loop chunk steps\n      assert(isUint8Array(value));\n      chunks.push(value);\n      length += value.byteLength;\n    }\n\n    // 3. Let fulfilledSteps given a byte sequence bytes be to queue\n    //    a fetch task to run processBody given bytes, with\n    //    taskDestination.\n    const fulfilledSteps = bytes => queueMicrotask(() => {\n      processBody(bytes);\n    });\n    fulfilledSteps(Buffer.concat(chunks, length));\n  } catch (err) {\n    // 4. Let rejectedSteps be to queue a fetch task to run\n    //    processBodyError, with taskDestination.\n    queueMicrotask(() => processBodyError(err));\n  }\n\n  // 5. React to promise with fulfilledSteps and rejectedSteps.\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch\n};","map":{"version":3,"names":["redirectStatus","require","performance","isBlobLike","toUSVString","ReadableStreamFrom","assert","isUint8Array","crypto","badPorts","responseURL","response","urlList","length","toString","responseLocationURL","requestFragment","includes","status","location","headersList","get","URL","hash","requestCurrentURL","request","requestBadPort","url","test","protocol","port","isErrorLike","object","Error","constructor","name","isValidReasonPhrase","statusText","i","c","charCodeAt","isTokenChar","isValidHTTPToken","characters","isValidHeaderName","potentialValue","char","isValidHeaderValue","startsWith","endsWith","setRequestReferrerPolicyOnRedirect","actualResponse","policy","referrerPolicy","crossOriginResourcePolicyCheck","corsCheck","TAOCheck","appendFetchMetadata","httpRequest","header","mode","set","appendRequestOriginHeader","serializedOrigin","origin","responseTainting","append","method","sameOrigin","coarsenedSharedCurrentTime","crossOriginIsolatedCapability","now","createOpaqueTimingInfo","timingInfo","startTime","redirectStartTime","redirectEndTime","postRedirectStartTime","finalServiceWorkerStartTime","finalNetworkResponseStartTime","finalNetworkRequestStartTime","endTime","encodedBodySize","decodedBodySize","finalConnectionTimingInfo","makePolicyContainer","clonePolicyContainer","determineRequestsReferrer","environment","client","referrerSource","referrer","globalObject","self","href","urlProtocol","temp","referrerOrigin","referrerUrl","stripURLForReferrer","areSameOrigin","isNonPotentiallyTrustWorthy","isURLPotentiallyTrustworthy","originOnly","urlObject","username","password","isOriginPotentiallyTrustworthy","originAsURL","hostname","bytesMatch","bytes","metadataList","undefined","parsedMetadata","parseMetadata","metadata","sort","d","algo","localeCompare","item","algorithm","expectedValue","actualValue","createHash","update","digest","parseHashWithOptions","result","empty","supportedHashes","getHashes","token","split","parsedToken","exec","groups","toLowerCase","push","tryUpgradeRequestToAPotentiallyTrustworthyURL","A","B","createDeferredPromise","res","rej","promise","Promise","resolve","reject","isAborted","fetchParams","controller","state","isCancelled","normalizeMethod","toUpperCase","serializeJavascriptValueToJSONString","value","JSON","stringify","TypeError","esIteratorPrototype","Object","getPrototypeOf","Symbol","iterator","makeIterator","next","toStringTag","setPrototypeOf","fullyReadBody","body","processBody","processBodyError","chunks","reader","stream","getReader","done","read","byteLength","fulfilledSteps","queueMicrotask","Buffer","concat","err","hasOwn","dict","key","prototype","hasOwnProperty","call","module","exports"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/undici/lib/fetch/util.js"],"sourcesContent":["'use strict'\n\nconst { redirectStatus } = require('./constants')\nconst { performance } = require('perf_hooks')\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = require('../core/util')\nconst assert = require('assert')\nconst { isUint8Array } = require('util/types')\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto\n\ntry {\n  crypto = require('crypto')\n} catch {\n\n}\n\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',\n  '10080'\n]\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location')\n\n  // 3. If location is a value, then set location to the result of parsing\n  // location with response’s URL.\n  location = location ? new URL(location, responseURL(response)) : null\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isTokenChar (c) {\n  return !(\n    c >= 0x7f ||\n    c <= 0x20 ||\n    c === '(' ||\n    c === ')' ||\n    c === '<' ||\n    c === '>' ||\n    c === '@' ||\n    c === ',' ||\n    c === ';' ||\n    c === ':' ||\n    c === '\\\\' ||\n    c === '\"' ||\n    c === '/' ||\n    c === '[' ||\n    c === ']' ||\n    c === '?' ||\n    c === '=' ||\n    c === '{' ||\n    c === '}'\n  )\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken (characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i)\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false\n    }\n  }\n  return true\n}\n\n// https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\nfunction isValidHeaderName (potentialValue) {\n  if (potentialValue.length === 0) {\n    return false\n  }\n\n  for (const char of potentialValue) {\n    if (!isValidHTTPToken(char)) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (\n    potentialValue.startsWith('\\t') ||\n    potentialValue.startsWith(' ') ||\n    potentialValue.endsWith('\\t') ||\n    potentialValue.endsWith(' ')\n  ) {\n    return false\n  }\n\n  if (\n    potentialValue.includes('\\0') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\n')\n  ) {\n    return false\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  // TODO:  https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n  const policy = ''\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('Origin', serializedOrigin)\n    }\n\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('Origin', serializedOrigin)\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now()\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Return no-referrer when empty or policy says so\n  if (policy == null || policy === '' || policy === 'no-referrer') {\n    return 'no-referrer'\n  }\n\n  // 2. Let environment be the request client\n  const environment = request.client\n  let referrerSource = null\n\n  /**\n   * 3, Switch on request’s referrer:\n    \"client\"\n      If environment’s global object is a Window object, then\n        Let document be the associated Document of environment’s global object.\n        If document’s origin is an opaque origin, return no referrer.\n        While document is an iframe srcdoc document,\n        let document be document’s browsing context’s browsing context container’s node document.\n        Let referrerSource be document’s URL.\n\n      Otherwise, let referrerSource be environment’s creation URL.\n\n    a URL\n    Let referrerSource be request’s referrer.\n   */\n  if (request.referrer === 'client') {\n    // Not defined in Node but part of the spec\n    if (request.client?.globalObject?.constructor?.name === 'Window' ) { // eslint-disable-line\n      const origin = environment.globalObject.self?.origin ?? environment.globalObject.location?.origin\n\n      // If document’s origin is an opaque origin, return no referrer.\n      if (origin == null || origin === 'null') return 'no-referrer'\n\n      // Let referrerSource be document’s URL.\n      referrerSource = new URL(environment.globalObject.location.href)\n    } else {\n      // 3(a)(II) If environment's global object is not Window,\n      // Let referrerSource be environments creationURL\n      if (environment?.globalObject?.location == null) {\n        return 'no-referrer'\n      }\n\n      referrerSource = new URL(environment.globalObject.location.href)\n    }\n  } else if (request.referrer instanceof URL) {\n    // 3(b) If requests's referrer is a URL instance, then make\n    // referrerSource be requests's referrer.\n    referrerSource = request.referrer\n  } else {\n    // If referrerSource neither client nor instance of URL\n    // then return \"no-referrer\".\n    return 'no-referrer'\n  }\n\n  const urlProtocol = referrerSource.protocol\n\n  // If url's scheme is a local scheme (i.e. one of \"about\", \"data\", \"javascript\", \"file\")\n  // then return \"no-referrer\".\n  if (\n    urlProtocol === 'about:' || urlProtocol === 'data:' ||\n    urlProtocol === 'blob:'\n  ) {\n    return 'no-referrer'\n  }\n\n  let temp\n  let referrerOrigin\n  // 4. Let requests's referrerURL be the result of stripping referrer\n  // source for use as referrer (using util function, without origin only)\n  const referrerUrl = (temp = stripURLForReferrer(referrerSource)).length > 4096\n  // 5. Let referrerOrigin be the result of stripping referrer\n  // source for use as referrer (using util function, with originOnly true)\n    ? (referrerOrigin = stripURLForReferrer(referrerSource, true))\n  // 6. If result of seralizing referrerUrl is a string whose length is greater than\n  // 4096, then set referrerURL to referrerOrigin\n    : temp\n  const areSameOrigin = sameOrigin(request, referrerUrl)\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerUrl) &&\n    !isURLPotentiallyTrustworthy(request.url)\n\n  // NOTE: How to treat step 7?\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url': return referrerUrl\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer'\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerUrl : referrerOrigin\n    case 'strict-origin-when-cross-origin':\n      /**\n         * 1. If the origin of referrerURL and the origin of request’s current URL are the same,\n         * then return referrerURL.\n         * 2. If referrerURL is a potentially trustworthy URL and request’s current URL is not a\n         * potentially trustworthy URL, then return no referrer.\n         * 3. Return referrerOrigin\n      */\n      if (areSameOrigin) return referrerOrigin\n      // else return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n    case 'strict-origin': // eslint-disable-line\n      /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n      /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n\n    default: // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n  }\n\n  function stripURLForReferrer (url, originOnly = false) {\n    const urlObject = new URL(url.href)\n    urlObject.username = ''\n    urlObject.password = ''\n    urlObject.hash = ''\n\n    return originOnly ? urlObject.origin : urlObject.href\n  }\n}\n\nfunction isURLPotentiallyTrustworthy (url) {\n  if (!(url instanceof URL)) {\n    return false\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true\n\n  // If file, return true\n  if (url.protocol === 'file:') return true\n\n  return isOriginPotentiallyTrustworthy(url.origin)\n\n  function isOriginPotentiallyTrustworthy (origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false\n\n    const originAsURL = new URL(origin)\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) ||\n     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||\n     (originAsURL.hostname.endsWith('.localhost'))) {\n      return true\n    }\n\n    // If any other, return false\n    return false\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  // Note: this will only work for SHA- algorithms and it's lazy *at best*.\n  const metadata = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo))\n\n  // 5. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    // Note: \"applying algorithm to bytes\" converts the result to base64\n    const actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (actualValue === expectedValue) {\n      return true\n    }\n  }\n\n  // 6. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// hash-algo is defined in Content Security Policy 2 Section 4.2\n// base64-value is similary defined there\n// VCHAR is defined https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={1,2}))( +[\\x21-\\x7e]?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  const supportedHashes = crypto.getHashes()\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  // \"opaque origin\" is an internal value we cannot access, ignore.\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n// https://fetch.spec.whatwg.org/#concept-method-normalize\nfunction normalizeMethod (method) {\n  return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method)\n    ? method.toUpperCase()\n    : method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n// https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\nfunction makeIterator (iterator, name) {\n  const i = {\n    next () {\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      return iterator.next()\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  }\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype)\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let promise be the result of fully reading body as promise\n  //    given body.\n  try {\n    /** @type {Uint8Array[]} */\n    const chunks = []\n    let length = 0\n\n    const reader = body.stream.getReader()\n\n    while (true) {\n      const { done, value } = await reader.read()\n\n      if (done === true) {\n        break\n      }\n\n      // read-loop chunk steps\n      assert(isUint8Array(value))\n\n      chunks.push(value)\n      length += value.byteLength\n    }\n\n    // 3. Let fulfilledSteps given a byte sequence bytes be to queue\n    //    a fetch task to run processBody given bytes, with\n    //    taskDestination.\n    const fulfilledSteps = (bytes) => queueMicrotask(() => {\n      processBody(bytes)\n    })\n\n    fulfilledSteps(Buffer.concat(chunks, length))\n  } catch (err) {\n    // 4. Let rejectedSteps be to queue a fetch task to run\n    //    processBodyError, with taskDestination.\n    queueMicrotask(() => processBodyError(err))\n  }\n\n  // 5. React to promise with fulfilledSteps and rejectedSteps.\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key))\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}