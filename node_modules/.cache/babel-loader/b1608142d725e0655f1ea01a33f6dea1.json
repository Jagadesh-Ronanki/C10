{"ast":null,"code":"const assert = require('assert');\nconst {\n  atob\n} = require('buffer');\nconst {\n  isValidHTTPToken\n} = require('./util');\nconst encoder = new TextEncoder();\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor(dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:');\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true);\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5);\n\n  // 4. Let position point at the start of input.\n  const position = {\n    position: 0\n  };\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePoints(char => char !== ',', input, position);\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Note: This will only remove U+0020 SPACE code\n  // points, if any.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length;\n  mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, '');\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure';\n  }\n\n  // 8. Advance position by 1.\n  position.position++;\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1);\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  /** @type {Uint8Array|string} */\n  let body = stringPercentDecode(encodedBody);\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = decodeURIComponent(new TextDecoder('utf-8').decode(body));\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody);\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure';\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6);\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '');\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1);\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType;\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType);\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return {\n    mimeType: mimeTypeRecord,\n    body\n  };\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer(url) {\n  let excludeFragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // 1. Let output be url’s scheme and U+003A (:) concatenated.\n  let output = url.protocol;\n\n  // 2. If url’s host is non-null:\n  if (url.host.length > 0) {\n    // 1. Append \"//\" to output.\n    output += '//';\n\n    // 2. If url includes credentials, then:\n    if (url.username.length > 0 || url.password.length > 0) {\n      // 1. Append url’s username to output.\n      output += url.username;\n\n      // 2. If url’s password is not the empty string, then append U+003A (:),\n      // followed by url’s password, to output.\n      if (url.password.length > 0) {\n        output += ':' + url.password;\n      }\n\n      // 3. Append U+0040 (@) to output.\n      output += '@';\n    }\n\n    // 3. Append url’s host, serialized, to output.\n    output += decodeURIComponent(url.host);\n\n    // 4. If url’s port is non-null, append U+003A (:) followed by url’s port,\n    // serialized, to output.\n    if (url.port.length > 0) {\n      output += ':' + url.port;\n    }\n  }\n\n  // 3. If url’s host is null, url does not have an opaque path,\n  // url’s path’s size is greater than 1, and url’s path[0]\n  // is the empty string, then append U+002F (/) followed by\n  // U+002E (.) to output.\n  // Note: This prevents web+demo:/.//not-a-host/ or web+demo:/path/..//not-a-host/,\n  // when parsed and then serialized, from ending up as web+demo://not-a-host/\n  // (they end up as web+demo:/.//not-a-host/).\n  // Undici implementation note: url's path[0] can never be an\n  // empty string, so we have to slightly alter what the spec says.\n  if (url.host.length === 0 && url.pathname.length > 1 && url.href.slice(url.protocol.length + 1)[0] === '.') {\n    output += '/.';\n  }\n\n  // 4. Append the result of URL path serializing url to output.\n  output += url.pathname;\n\n  // 5. If url’s query is non-null, append U+003F (?),\n  // followed by url’s query, to output.\n  if (url.search.length > 0) {\n    output += url.search;\n  }\n\n  // 6. If exclude fragment is false and url’s fragment is non-null,\n  // then append U+0023 (#), followed by url’s fragment, to output.\n  if (excludeFragment === false && url.hash.length > 0) {\n    output += url.hash;\n  }\n\n  // 7. Return output.\n  return output;\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints(condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = '';\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position];\n\n    // 2. Advance position by 1.\n    position.position++;\n  }\n\n  // 3. Return result.\n  return result;\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode(input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input);\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes);\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode(input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = [];\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i];\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte);\n\n      // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n      // after byte in input are not in the ranges\n      // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n      // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n      // to output.\n    } else if (byte === 0x25 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {\n      output.push(0x25);\n\n      // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n      const bytePoint = Number.parseInt(nextTwoBytes, 16);\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint);\n\n      // 3. Skip the next two bytes in input.\n      i += 2;\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.from(output);\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType(input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = input.trim();\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = {\n    position: 0\n  };\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePoints(char => char !== '/', input, position);\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n    return 'failure';\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure';\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++;\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePoints(char => char !== ';', input, position);\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = subtype.trim();\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n    return 'failure';\n  }\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: type.toLowerCase(),\n    subtype: subtype.toLowerCase(),\n    /** @type {Map<string, string>} */\n    parameters: new Map()\n  };\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++;\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n    // https://fetch.spec.whatwg.org/#http-whitespace\n    char => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char),\n    // eslint-disable-line\n    input, position);\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(char => char !== ';' && char !== '=', input, position);\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase();\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue;\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++;\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break;\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null;\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true);\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePoints(char => char !== ';', input, position);\n\n      // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePoints(char => char !== ';', input, position);\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      // Note: it says \"trailing\" whitespace; leading is fine.\n      parameterValue = parameterValue.trimEnd();\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue;\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (parameterName.length !== 0 && /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) &&\n    // https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n    !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) &&\n    // eslint-disable-line\n    !mimeType.parameters.has(parameterName)) {\n      mimeType.parameters.set(parameterName, parameterValue);\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType;\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64(data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, ''); // eslint-disable-line\n\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '');\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure';\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure';\n  }\n  const binary = atob(data);\n  const bytes = new Uint8Array(binary.length);\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte);\n  }\n  return bytes;\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString(input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position;\n\n  // 2. Let value be the empty string.\n  let value = '';\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"');\n\n  // 4. Advance position by 1.\n  position.position++;\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(char => char !== '\"' && char !== '\\\\', input, position);\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break;\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position];\n\n    // 4. Advance position by 1.\n    position.position++;\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\';\n        break;\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position];\n\n      // 3. Advance position by 1.\n      position.position++;\n\n      // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"');\n\n      // 2. Break.\n      break;\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value;\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position);\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType(mimeType) {\n  assert(mimeType !== 'failure');\n  const {\n    type,\n    subtype,\n    parameters\n  } = mimeType;\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = `${type}/${subtype}`;\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';';\n\n    // 2. Append name to serialization.\n    serialization += name;\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '=';\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!isValidHTTPToken(value)) {\n      // 1. Precede each occurence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1');\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value;\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"';\n    }\n\n    // 5. Append value to serialization.\n    serialization += value;\n  }\n\n  // 3. Return serialization.\n  return serialization;\n}\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType\n};","map":{"version":3,"names":["assert","require","atob","isValidHTTPToken","encoder","TextEncoder","dataURLProcessor","dataURL","protocol","input","URLSerializer","slice","position","mimeType","collectASequenceOfCodePoints","char","mimeTypeLength","length","replace","encodedBody","body","stringPercentDecode","test","stringBody","decodeURIComponent","TextDecoder","decode","forgivingBase64","startsWith","mimeTypeRecord","parseMIMEType","url","excludeFragment","output","host","username","password","port","pathname","href","search","hash","condition","result","bytes","encode","percentDecode","i","byte","push","String","fromCharCode","nextTwoBytes","bytePoint","Number","parseInt","Uint8Array","from","trim","type","subtype","toLowerCase","parameters","Map","parameterName","parameterValue","collectAnHTTPQuotedString","trimEnd","has","set","data","binary","charCodeAt","extractValue","positionStart","value","quoteOrBackslash","serializeAMimeType","serialization","name","entries","module","exports"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/undici/lib/fetch/dataURL.js"],"sourcesContent":["const assert = require('assert')\nconst { atob } = require('buffer')\nconst { isValidHTTPToken } = require('./util')\n\nconst encoder = new TextEncoder()\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePoints(\n    (char) => char !== ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Note: This will only remove U+0020 SPACE code\n  // points, if any.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, '')\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  /** @type {Uint8Array|string} */\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = decodeURIComponent(new TextDecoder('utf-8').decode(body))\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  // 1. Let output be url’s scheme and U+003A (:) concatenated.\n  let output = url.protocol\n\n  // 2. If url’s host is non-null:\n  if (url.host.length > 0) {\n    // 1. Append \"//\" to output.\n    output += '//'\n\n    // 2. If url includes credentials, then:\n    if (url.username.length > 0 || url.password.length > 0) {\n      // 1. Append url’s username to output.\n      output += url.username\n\n      // 2. If url’s password is not the empty string, then append U+003A (:),\n      // followed by url’s password, to output.\n      if (url.password.length > 0) {\n        output += ':' + url.password\n      }\n\n      // 3. Append U+0040 (@) to output.\n      output += '@'\n    }\n\n    // 3. Append url’s host, serialized, to output.\n    output += decodeURIComponent(url.host)\n\n    // 4. If url’s port is non-null, append U+003A (:) followed by url’s port,\n    // serialized, to output.\n    if (url.port.length > 0) {\n      output += ':' + url.port\n    }\n  }\n\n  // 3. If url’s host is null, url does not have an opaque path,\n  // url’s path’s size is greater than 1, and url’s path[0]\n  // is the empty string, then append U+002F (/) followed by\n  // U+002E (.) to output.\n  // Note: This prevents web+demo:/.//not-a-host/ or web+demo:/path/..//not-a-host/,\n  // when parsed and then serialized, from ending up as web+demo://not-a-host/\n  // (they end up as web+demo:/.//not-a-host/).\n  // Undici implementation note: url's path[0] can never be an\n  // empty string, so we have to slightly alter what the spec says.\n  if (\n    url.host.length === 0 &&\n    url.pathname.length > 1 &&\n    url.href.slice(url.protocol.length + 1)[0] === '.'\n  ) {\n    output += '/.'\n  }\n\n  // 4. Append the result of URL path serializing url to output.\n  output += url.pathname\n\n  // 5. If url’s query is non-null, append U+003F (?),\n  // followed by url’s query, to output.\n  if (url.search.length > 0) {\n    output += url.search\n  }\n\n  // 6. If exclude fragment is false and url’s fragment is non-null,\n  // then append U+0023 (#), followed by url’s fragment, to output.\n  if (excludeFragment === false && url.hash.length > 0) {\n    output += url.hash\n  }\n\n  // 7. Return output.\n  return output\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = []\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte)\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))\n    ) {\n      output.push(0x25)\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2])\n      const bytePoint = Number.parseInt(nextTwoBytes, 16)\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint)\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.from(output)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = input.trim()\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePoints(\n    (char) => char !== '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePoints(\n    (char) => char !== ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = subtype.trim()\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n    return 'failure'\n  }\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: type.toLowerCase(),\n    subtype: subtype.toLowerCase(),\n    /** @type {Map<string, string>} */\n    parameters: new Map()\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      (char) => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char), // eslint-disable-line\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePoints(\n        (char) => char !== ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePoints(\n        (char) => char !== ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      // Note: it says \"trailing\" whitespace; leading is fine.\n      parameterValue = parameterValue.trimEnd()\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) &&\n      // https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n      !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) &&  // eslint-disable-line\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, '')  // eslint-disable-line\n\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '')\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure'\n  }\n\n  const binary = atob(data)\n  const bytes = new Uint8Array(binary.length)\n\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte)\n  }\n\n  return bytes\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { type, subtype, parameters } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = `${type}/${subtype}`\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!isValidHTTPToken(value)) {\n      // 1. Precede each occurence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType\n}\n"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAM;EAAEC;AAAK,CAAC,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAM;EAAEE;AAAiB,CAAC,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAE9C,MAAMG,OAAO,GAAG,IAAIC,WAAW,EAAE;;AAEjC;AACA;AACA,SAASC,gBAAgB,CAAEC,OAAO,EAAE;EAClC;EACAP,MAAM,CAACO,OAAO,CAACC,QAAQ,KAAK,OAAO,CAAC;;EAEpC;EACA;EACA;EACA,IAAIC,KAAK,GAAGC,aAAa,CAACH,OAAO,EAAE,IAAI,CAAC;;EAExC;EACAE,KAAK,GAAGA,KAAK,CAACE,KAAK,CAAC,CAAC,CAAC;;EAEtB;EACA,MAAMC,QAAQ,GAAG;IAAEA,QAAQ,EAAE;EAAE,CAAC;;EAEhC;EACA;EACA;EACA,IAAIC,QAAQ,GAAGC,4BAA4B,CACxCC,IAAI,IAAKA,IAAI,KAAK,GAAG,EACtBN,KAAK,EACLG,QAAQ,CACT;;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMI,cAAc,GAAGH,QAAQ,CAACI,MAAM;EACtCJ,QAAQ,GAAGA,QAAQ,CAACK,OAAO,CAAC,wBAAwB,EAAE,EAAE,CAAC;;EAEzD;EACA;EACA,IAAIN,QAAQ,CAACA,QAAQ,IAAIH,KAAK,CAACQ,MAAM,EAAE;IACrC,OAAO,SAAS;EAClB;;EAEA;EACAL,QAAQ,CAACA,QAAQ,EAAE;;EAEnB;EACA,MAAMO,WAAW,GAAGV,KAAK,CAACE,KAAK,CAACK,cAAc,GAAG,CAAC,CAAC;;EAEnD;EACA;EACA,IAAII,IAAI,GAAGC,mBAAmB,CAACF,WAAW,CAAC;;EAE3C;EACA;EACA;EACA,IAAI,uBAAuB,CAACG,IAAI,CAACT,QAAQ,CAAC,EAAE;IAC1C;IACA,MAAMU,UAAU,GAAGC,kBAAkB,CAAC,IAAIC,WAAW,CAAC,OAAO,CAAC,CAACC,MAAM,CAACN,IAAI,CAAC,CAAC;IAC5E;IACA;IACAA,IAAI,GAAGO,eAAe,CAACJ,UAAU,CAAC;;IAElC;IACA,IAAIH,IAAI,KAAK,SAAS,EAAE;MACtB,OAAO,SAAS;IAClB;;IAEA;IACAP,QAAQ,GAAGA,QAAQ,CAACF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;;IAEhC;IACA;IACAE,QAAQ,GAAGA,QAAQ,CAACK,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;;IAE7C;IACAL,QAAQ,GAAGA,QAAQ,CAACF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAClC;;EAEA;EACA;EACA,IAAIE,QAAQ,CAACe,UAAU,CAAC,GAAG,CAAC,EAAE;IAC5Bf,QAAQ,GAAG,YAAY,GAAGA,QAAQ;EACpC;;EAEA;EACA;EACA,IAAIgB,cAAc,GAAGC,aAAa,CAACjB,QAAQ,CAAC;;EAE5C;EACA;EACA,IAAIgB,cAAc,KAAK,SAAS,EAAE;IAChCA,cAAc,GAAGC,aAAa,CAAC,6BAA6B,CAAC;EAC/D;;EAEA;EACA;EACA;EACA,OAAO;IAAEjB,QAAQ,EAAEgB,cAAc;IAAET;EAAK,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASV,aAAa,CAAEqB,GAAG,EAA2B;EAAA,IAAzBC,eAAe,uEAAG,KAAK;EAClD;EACA,IAAIC,MAAM,GAAGF,GAAG,CAACvB,QAAQ;;EAEzB;EACA,IAAIuB,GAAG,CAACG,IAAI,CAACjB,MAAM,GAAG,CAAC,EAAE;IACvB;IACAgB,MAAM,IAAI,IAAI;;IAEd;IACA,IAAIF,GAAG,CAACI,QAAQ,CAAClB,MAAM,GAAG,CAAC,IAAIc,GAAG,CAACK,QAAQ,CAACnB,MAAM,GAAG,CAAC,EAAE;MACtD;MACAgB,MAAM,IAAIF,GAAG,CAACI,QAAQ;;MAEtB;MACA;MACA,IAAIJ,GAAG,CAACK,QAAQ,CAACnB,MAAM,GAAG,CAAC,EAAE;QAC3BgB,MAAM,IAAI,GAAG,GAAGF,GAAG,CAACK,QAAQ;MAC9B;;MAEA;MACAH,MAAM,IAAI,GAAG;IACf;;IAEA;IACAA,MAAM,IAAIT,kBAAkB,CAACO,GAAG,CAACG,IAAI,CAAC;;IAEtC;IACA;IACA,IAAIH,GAAG,CAACM,IAAI,CAACpB,MAAM,GAAG,CAAC,EAAE;MACvBgB,MAAM,IAAI,GAAG,GAAGF,GAAG,CAACM,IAAI;IAC1B;EACF;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IACEN,GAAG,CAACG,IAAI,CAACjB,MAAM,KAAK,CAAC,IACrBc,GAAG,CAACO,QAAQ,CAACrB,MAAM,GAAG,CAAC,IACvBc,GAAG,CAACQ,IAAI,CAAC5B,KAAK,CAACoB,GAAG,CAACvB,QAAQ,CAACS,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAClD;IACAgB,MAAM,IAAI,IAAI;EAChB;;EAEA;EACAA,MAAM,IAAIF,GAAG,CAACO,QAAQ;;EAEtB;EACA;EACA,IAAIP,GAAG,CAACS,MAAM,CAACvB,MAAM,GAAG,CAAC,EAAE;IACzBgB,MAAM,IAAIF,GAAG,CAACS,MAAM;EACtB;;EAEA;EACA;EACA,IAAIR,eAAe,KAAK,KAAK,IAAID,GAAG,CAACU,IAAI,CAACxB,MAAM,GAAG,CAAC,EAAE;IACpDgB,MAAM,IAAIF,GAAG,CAACU,IAAI;EACpB;;EAEA;EACA,OAAOR,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASnB,4BAA4B,CAAE4B,SAAS,EAAEjC,KAAK,EAAEG,QAAQ,EAAE;EACjE;EACA,IAAI+B,MAAM,GAAG,EAAE;;EAEf;EACA;EACA,OAAO/B,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACQ,MAAM,IAAIyB,SAAS,CAACjC,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC,CAAC,EAAE;IAC9E;IACA+B,MAAM,IAAIlC,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC;;IAElC;IACAA,QAAQ,CAACA,QAAQ,EAAE;EACrB;;EAEA;EACA,OAAO+B,MAAM;AACf;;AAEA;AACA;AACA,SAAStB,mBAAmB,CAAEZ,KAAK,EAAE;EACnC;EACA,MAAMmC,KAAK,GAAGxC,OAAO,CAACyC,MAAM,CAACpC,KAAK,CAAC;;EAEnC;EACA,OAAOqC,aAAa,CAACF,KAAK,CAAC;AAC7B;;AAEA;AACA;AACA,SAASE,aAAa,CAAErC,KAAK,EAAE;EAC7B;EACA;EACA,MAAMwB,MAAM,GAAG,EAAE;;EAEjB;EACA,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtC,KAAK,CAACQ,MAAM,EAAE8B,CAAC,EAAE,EAAE;IACrC,MAAMC,IAAI,GAAGvC,KAAK,CAACsC,CAAC,CAAC;;IAErB;IACA,IAAIC,IAAI,KAAK,IAAI,EAAE;MACjBf,MAAM,CAACgB,IAAI,CAACD,IAAI,CAAC;;MAEnB;MACA;MACA;MACA;MACA;IACA,CAAC,MAAM,IACLA,IAAI,KAAK,IAAI,IACb,CAAC,mBAAmB,CAAC1B,IAAI,CAAC4B,MAAM,CAACC,YAAY,CAAC1C,KAAK,CAACsC,CAAC,GAAG,CAAC,CAAC,EAAEtC,KAAK,CAACsC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAC1E;MACAd,MAAM,CAACgB,IAAI,CAAC,IAAI,CAAC;;MAEnB;IACA,CAAC,MAAM;MACL;MACA;MACA,MAAMG,YAAY,GAAGF,MAAM,CAACC,YAAY,CAAC1C,KAAK,CAACsC,CAAC,GAAG,CAAC,CAAC,EAAEtC,KAAK,CAACsC,CAAC,GAAG,CAAC,CAAC,CAAC;MACpE,MAAMM,SAAS,GAAGC,MAAM,CAACC,QAAQ,CAACH,YAAY,EAAE,EAAE,CAAC;;MAEnD;MACAnB,MAAM,CAACgB,IAAI,CAACI,SAAS,CAAC;;MAEtB;MACAN,CAAC,IAAI,CAAC;IACR;EACF;;EAEA;EACA,OAAOS,UAAU,CAACC,IAAI,CAACxB,MAAM,CAAC;AAChC;;AAEA;AACA;AACA,SAASH,aAAa,CAAErB,KAAK,EAAE;EAC7B;EACA;EACAA,KAAK,GAAGA,KAAK,CAACiD,IAAI,EAAE;;EAEpB;EACA;EACA,MAAM9C,QAAQ,GAAG;IAAEA,QAAQ,EAAE;EAAE,CAAC;;EAEhC;EACA;EACA;EACA,MAAM+C,IAAI,GAAG7C,4BAA4B,CACtCC,IAAI,IAAKA,IAAI,KAAK,GAAG,EACtBN,KAAK,EACLG,QAAQ,CACT;;EAED;EACA;EACA;EACA,IAAI+C,IAAI,CAAC1C,MAAM,KAAK,CAAC,IAAI,CAAC,2BAA2B,CAACK,IAAI,CAACqC,IAAI,CAAC,EAAE;IAChE,OAAO,SAAS;EAClB;;EAEA;EACA;EACA,IAAI/C,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACQ,MAAM,EAAE;IACpC,OAAO,SAAS;EAClB;;EAEA;EACAL,QAAQ,CAACA,QAAQ,EAAE;;EAEnB;EACA;EACA;EACA,IAAIgD,OAAO,GAAG9C,4BAA4B,CACvCC,IAAI,IAAKA,IAAI,KAAK,GAAG,EACtBN,KAAK,EACLG,QAAQ,CACT;;EAED;EACAgD,OAAO,GAAGA,OAAO,CAACF,IAAI,EAAE;;EAExB;EACA;EACA,IAAIE,OAAO,CAAC3C,MAAM,KAAK,CAAC,IAAI,CAAC,2BAA2B,CAACK,IAAI,CAACsC,OAAO,CAAC,EAAE;IACtE,OAAO,SAAS;EAClB;;EAEA;EACA;EACA;EACA;EACA,MAAM/C,QAAQ,GAAG;IACf8C,IAAI,EAAEA,IAAI,CAACE,WAAW,EAAE;IACxBD,OAAO,EAAEA,OAAO,CAACC,WAAW,EAAE;IAC9B;IACAC,UAAU,EAAE,IAAIC,GAAG;EACrB,CAAC;;EAED;EACA,OAAOnD,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACQ,MAAM,EAAE;IACvC;IACAL,QAAQ,CAACA,QAAQ,EAAE;;IAEnB;IACA;IACAE,4BAA4B;IAC1B;IACCC,IAAI,IAAK,+BAA+B,CAACO,IAAI,CAACP,IAAI,CAAC;IAAE;IACtDN,KAAK,EACLG,QAAQ,CACT;;IAED;IACA;IACA;IACA,IAAIoD,aAAa,GAAGlD,4BAA4B,CAC7CC,IAAI,IAAKA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EACtCN,KAAK,EACLG,QAAQ,CACT;;IAED;IACA;IACAoD,aAAa,GAAGA,aAAa,CAACH,WAAW,EAAE;;IAE3C;IACA,IAAIjD,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACQ,MAAM,EAAE;MACpC;MACA;MACA,IAAIR,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC,KAAK,GAAG,EAAE;QACpC;MACF;;MAEA;MACAA,QAAQ,CAACA,QAAQ,EAAE;IACrB;;IAEA;IACA,IAAIA,QAAQ,CAACA,QAAQ,GAAGH,KAAK,CAACQ,MAAM,EAAE;MACpC;IACF;;IAEA;IACA,IAAIgD,cAAc,GAAG,IAAI;;IAEzB;IACA;IACA,IAAIxD,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC,KAAK,GAAG,EAAE;MACpC;MACA;MACA;MACAqD,cAAc,GAAGC,yBAAyB,CAACzD,KAAK,EAAEG,QAAQ,EAAE,IAAI,CAAC;;MAEjE;MACA;MACAE,4BAA4B,CACzBC,IAAI,IAAKA,IAAI,KAAK,GAAG,EACtBN,KAAK,EACLG,QAAQ,CACT;;MAEH;IACA,CAAC,MAAM;MACL;MACA;MACA;MACAqD,cAAc,GAAGnD,4BAA4B,CAC1CC,IAAI,IAAKA,IAAI,KAAK,GAAG,EACtBN,KAAK,EACLG,QAAQ,CACT;;MAED;MACA;MACAqD,cAAc,GAAGA,cAAc,CAACE,OAAO,EAAE;;MAEzC;MACA,IAAIF,cAAc,CAAChD,MAAM,KAAK,CAAC,EAAE;QAC/B;MACF;IACF;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA,IACE+C,aAAa,CAAC/C,MAAM,KAAK,CAAC,IAC1B,2BAA2B,CAACK,IAAI,CAAC0C,aAAa,CAAC;IAC/C;IACA,CAAC,iDAAiD,CAAC1C,IAAI,CAAC2C,cAAc,CAAC;IAAK;IAC5E,CAACpD,QAAQ,CAACiD,UAAU,CAACM,GAAG,CAACJ,aAAa,CAAC,EACvC;MACAnD,QAAQ,CAACiD,UAAU,CAACO,GAAG,CAACL,aAAa,EAAEC,cAAc,CAAC;IACxD;EACF;;EAEA;EACA,OAAOpD,QAAQ;AACjB;;AAEA;AACA;AACA,SAASc,eAAe,CAAE2C,IAAI,EAAE;EAC9B;EACAA,IAAI,GAAGA,IAAI,CAACpD,OAAO,CAAC,mCAAmC,EAAE,EAAE,CAAC,EAAE;;EAE9D;EACA;EACA,IAAIoD,IAAI,CAACrD,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IACzB;IACA;IACAqD,IAAI,GAAGA,IAAI,CAACpD,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;EACjC;;EAEA;EACA;EACA,IAAIoD,IAAI,CAACrD,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IACzB,OAAO,SAAS;EAClB;;EAEA;EACA;EACA;EACA;EACA;EACA,IAAI,gBAAgB,CAACK,IAAI,CAACgD,IAAI,CAAC,EAAE;IAC/B,OAAO,SAAS;EAClB;EAEA,MAAMC,MAAM,GAAGrE,IAAI,CAACoE,IAAI,CAAC;EACzB,MAAM1B,KAAK,GAAG,IAAIY,UAAU,CAACe,MAAM,CAACtD,MAAM,CAAC;EAE3C,KAAK,IAAI+B,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGuB,MAAM,CAACtD,MAAM,EAAE+B,IAAI,EAAE,EAAE;IAC/CJ,KAAK,CAACI,IAAI,CAAC,GAAGuB,MAAM,CAACC,UAAU,CAACxB,IAAI,CAAC;EACvC;EAEA,OAAOJ,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASsB,yBAAyB,CAAEzD,KAAK,EAAEG,QAAQ,EAAE6D,YAAY,EAAE;EACjE;EACA,MAAMC,aAAa,GAAG9D,QAAQ,CAACA,QAAQ;;EAEvC;EACA,IAAI+D,KAAK,GAAG,EAAE;;EAEd;EACA;EACA3E,MAAM,CAACS,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC,KAAK,GAAG,CAAC;;EAExC;EACAA,QAAQ,CAACA,QAAQ,EAAE;;EAEnB;EACA,OAAO,IAAI,EAAE;IACX;IACA;IACA;IACA+D,KAAK,IAAI7D,4BAA4B,CAClCC,IAAI,IAAKA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,EACvCN,KAAK,EACLG,QAAQ,CACT;;IAED;IACA,IAAIA,QAAQ,CAACA,QAAQ,IAAIH,KAAK,CAACQ,MAAM,EAAE;MACrC;IACF;;IAEA;IACA;IACA,MAAM2D,gBAAgB,GAAGnE,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC;;IAEjD;IACAA,QAAQ,CAACA,QAAQ,EAAE;;IAEnB;IACA,IAAIgE,gBAAgB,KAAK,IAAI,EAAE;MAC7B;MACA;MACA,IAAIhE,QAAQ,CAACA,QAAQ,IAAIH,KAAK,CAACQ,MAAM,EAAE;QACrC0D,KAAK,IAAI,IAAI;QACb;MACF;;MAEA;MACAA,KAAK,IAAIlE,KAAK,CAACG,QAAQ,CAACA,QAAQ,CAAC;;MAEjC;MACAA,QAAQ,CAACA,QAAQ,EAAE;;MAErB;IACA,CAAC,MAAM;MACL;MACAZ,MAAM,CAAC4E,gBAAgB,KAAK,GAAG,CAAC;;MAEhC;MACA;IACF;EACF;;EAEA;EACA,IAAIH,YAAY,EAAE;IAChB,OAAOE,KAAK;EACd;;EAEA;EACA;EACA,OAAOlE,KAAK,CAACE,KAAK,CAAC+D,aAAa,EAAE9D,QAAQ,CAACA,QAAQ,CAAC;AACtD;;AAEA;AACA;AACA;AACA,SAASiE,kBAAkB,CAAEhE,QAAQ,EAAE;EACrCb,MAAM,CAACa,QAAQ,KAAK,SAAS,CAAC;EAC9B,MAAM;IAAE8C,IAAI;IAAEC,OAAO;IAAEE;EAAW,CAAC,GAAGjD,QAAQ;;EAE9C;EACA;EACA,IAAIiE,aAAa,GAAI,GAAEnB,IAAK,IAAGC,OAAQ,EAAC;;EAExC;EACA,KAAK,IAAI,CAACmB,IAAI,EAAEJ,KAAK,CAAC,IAAIb,UAAU,CAACkB,OAAO,EAAE,EAAE;IAC9C;IACAF,aAAa,IAAI,GAAG;;IAEpB;IACAA,aAAa,IAAIC,IAAI;;IAErB;IACAD,aAAa,IAAI,GAAG;;IAEpB;IACA;IACA,IAAI,CAAC3E,gBAAgB,CAACwE,KAAK,CAAC,EAAE;MAC5B;MACA;MACAA,KAAK,GAAGA,KAAK,CAACzD,OAAO,CAAC,SAAS,EAAE,MAAM,CAAC;;MAExC;MACAyD,KAAK,GAAG,GAAG,GAAGA,KAAK;;MAEnB;MACAA,KAAK,IAAI,GAAG;IACd;;IAEA;IACAG,aAAa,IAAIH,KAAK;EACxB;;EAEA;EACA,OAAOG,aAAa;AACtB;AAEAG,MAAM,CAACC,OAAO,GAAG;EACf5E,gBAAgB;EAChBI,aAAa;EACbI,4BAA4B;EAC5BO,mBAAmB;EACnBS,aAAa;EACboC,yBAAyB;EACzBW;AACF,CAAC"},"metadata":{},"sourceType":"script"}