{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcHandler = void 0;\nconst raw_body_1 = __importDefault(require(\"raw-body\"));\nconst errors_1 = require(\"../../core/providers/errors\");\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\nclass JsonRpcHandler {\n  constructor(_provider) {\n    this._provider = _provider;\n    this.handleHttp = async (req, res) => {\n      this._setCorsHeaders(res);\n      if (req.method === \"OPTIONS\") {\n        this._sendEmptyResponse(res);\n        return;\n      }\n      let jsonHttpRequest;\n      try {\n        jsonHttpRequest = await _readJsonHttpRequest(req);\n      } catch (error) {\n        this._sendResponse(res, _handleError(error));\n        return;\n      }\n      if (Array.isArray(jsonHttpRequest)) {\n        const responses = await Promise.all(jsonHttpRequest.map(singleReq => this._handleSingleRequest(singleReq)));\n        this._sendResponse(res, responses);\n        return;\n      }\n      const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n      this._sendResponse(res, rpcResp);\n    };\n    this.handleWs = async ws => {\n      const subscriptions = [];\n      let isClosed = false;\n      const listener = payload => {\n        // Don't attempt to send a message to the websocket if we already know it is closed,\n        // or the current websocket connection isn't interested in the particular subscription.\n        if (isClosed || !subscriptions.includes(payload.subscription)) {\n          return;\n        }\n        try {\n          ws.send(JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload\n          }));\n        } catch (error) {\n          _handleError(error);\n        }\n      };\n      // Handle eth_subscribe notifications.\n      this._provider.addListener(\"notification\", listener);\n      ws.on(\"message\", async msg => {\n        let rpcReq;\n        let rpcResp;\n        try {\n          rpcReq = _readWsRequest(msg);\n          if (!(0, jsonrpc_1.isValidJsonRequest)(rpcReq)) {\n            throw new errors_1.InvalidRequestError(\"Invalid request\");\n          }\n          rpcResp = await this._handleRequest(rpcReq);\n          // If eth_subscribe was successful, keep track of the subscription id,\n          // so we can cleanup on websocket close.\n          if (rpcReq.method === \"eth_subscribe\" && (0, jsonrpc_1.isSuccessfulJsonResponse)(rpcResp)) {\n            subscriptions.push(rpcResp.result);\n          }\n        } catch (error) {\n          rpcResp = _handleError(error);\n        }\n        // Validate the RPC response.\n        if (!(0, jsonrpc_1.isValidJsonResponse)(rpcResp)) {\n          // Malformed response coming from the provider, report to user as an internal error.\n          rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n        }\n        if (rpcReq !== undefined) {\n          rpcResp.id = rpcReq.id;\n        }\n        ws.send(JSON.stringify(rpcResp));\n      });\n      ws.on(\"close\", () => {\n        // Remove eth_subscribe listener.\n        this._provider.removeListener(\"notification\", listener);\n        // Clear any active subscriptions for the closed websocket connection.\n        isClosed = true;\n        subscriptions.forEach(async subscriptionId => {\n          await this._provider.request({\n            method: \"eth_unsubscribe\",\n            params: [subscriptionId]\n          });\n        });\n      });\n    };\n    this._handleRequest = async req => {\n      const result = await this._provider.request({\n        method: req.method,\n        params: req.params\n      });\n      return {\n        jsonrpc: \"2.0\",\n        id: req.id,\n        result\n      };\n    };\n  }\n  _sendEmptyResponse(res) {\n    res.writeHead(200);\n    res.end();\n  }\n  _setCorsHeaders(res) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n  _sendResponse(res, rpcResp) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n  async _handleSingleRequest(req) {\n    if (!(0, jsonrpc_1.isValidJsonRequest)(req)) {\n      return _handleError(new errors_1.InvalidRequestError(\"Invalid request\"));\n    }\n    const rpcReq = req;\n    let rpcResp;\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    }\n    // Validate the RPC response.\n    if (!(0, jsonrpc_1.isValidJsonResponse)(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n    }\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n    return rpcResp;\n  }\n}\nexports.JsonRpcHandler = JsonRpcHandler;\nconst _readJsonHttpRequest = async req => {\n  let json;\n  try {\n    const buf = await (0, raw_body_1.default)(req);\n    const text = buf.toString();\n    json = JSON.parse(text);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n  return json;\n};\nconst _readWsRequest = msg => {\n  let json;\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n  return json;\n};\nconst _handleError = error => {\n  // extract the relevant fields from the error before wrapping it\n  let txHash;\n  let returnData;\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  }\n  if (error.data !== undefined) {\n    returnData = error.data;\n  }\n  // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n  if (!errors_1.ProviderError.isProviderError(error)) {\n    error = new errors_1.InternalError(error);\n  }\n  const response = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message\n    }\n  };\n  response.error.data = {\n    message: error.message\n  };\n  if (txHash !== undefined) {\n    response.error.data.txHash = txHash;\n  }\n  if (returnData !== undefined) {\n    response.error.data.data = returnData;\n  }\n  return response;\n};","map":{"version":3,"mappings":"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","names":["JsonRpcHandler","constructor","_provider","req","res","_setCorsHeaders","method","_sendEmptyResponse","jsonHttpRequest","_readJsonHttpRequest","error","_sendResponse","_handleError","Array","isArray","responses","Promise","all","map","singleReq","_handleSingleRequest","rpcResp","ws","subscriptions","isClosed","listener","payload","includes","subscription","send","JSON","stringify","jsonrpc","params","addListener","on","msg","rpcReq","_readWsRequest","errors_1","_handleRequest","push","result","undefined","id","removeListener","forEach","subscriptionId","request","writeHead","end","setHeader","statusCode","exports","json","buf","text","toString","parse","Error","message","txHash","returnData","transactionHash","data","isProviderError","response","code"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/hardhat/src/internal/hardhat-network/jsonrpc/handler.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from \"http\";\nimport getRawBody from \"raw-body\";\nimport WebSocket from \"ws\";\n\nimport { EIP1193Provider } from \"../../../types\";\nimport {\n  InternalError,\n  InvalidJsonInputError,\n  InvalidRequestError,\n  ProviderError,\n} from \"../../core/providers/errors\";\nimport {\n  FailedJsonRpcResponse,\n  isSuccessfulJsonResponse,\n  isValidJsonRequest,\n  isValidJsonResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n} from \"../../util/jsonrpc\";\n\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\nexport class JsonRpcHandler {\n  constructor(private readonly _provider: EIP1193Provider) {}\n\n  public handleHttp = async (req: IncomingMessage, res: ServerResponse) => {\n    this._setCorsHeaders(res);\n    if (req.method === \"OPTIONS\") {\n      this._sendEmptyResponse(res);\n      return;\n    }\n\n    let jsonHttpRequest: any;\n    try {\n      jsonHttpRequest = await _readJsonHttpRequest(req);\n    } catch (error) {\n      this._sendResponse(res, _handleError(error));\n      return;\n    }\n\n    if (Array.isArray(jsonHttpRequest)) {\n      const responses = await Promise.all(\n        jsonHttpRequest.map((singleReq: any) =>\n          this._handleSingleRequest(singleReq)\n        )\n      );\n\n      this._sendResponse(res, responses);\n      return;\n    }\n\n    const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n\n    this._sendResponse(res, rpcResp);\n  };\n\n  public handleWs = async (ws: WebSocket) => {\n    const subscriptions: string[] = [];\n    let isClosed = false;\n\n    const listener = (payload: { subscription: string; result: any }) => {\n      // Don't attempt to send a message to the websocket if we already know it is closed,\n      // or the current websocket connection isn't interested in the particular subscription.\n      if (isClosed || !subscriptions.includes(payload.subscription)) {\n        return;\n      }\n\n      try {\n        ws.send(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload,\n          })\n        );\n      } catch (error) {\n        _handleError(error);\n      }\n    };\n\n    // Handle eth_subscribe notifications.\n    this._provider.addListener(\"notification\", listener);\n\n    ws.on(\"message\", async (msg) => {\n      let rpcReq: JsonRpcRequest | undefined;\n      let rpcResp: JsonRpcResponse | undefined;\n\n      try {\n        rpcReq = _readWsRequest(msg as string);\n\n        if (!isValidJsonRequest(rpcReq)) {\n          throw new InvalidRequestError(\"Invalid request\");\n        }\n\n        rpcResp = await this._handleRequest(rpcReq);\n\n        // If eth_subscribe was successful, keep track of the subscription id,\n        // so we can cleanup on websocket close.\n        if (\n          rpcReq.method === \"eth_subscribe\" &&\n          isSuccessfulJsonResponse(rpcResp)\n        ) {\n          subscriptions.push(rpcResp.result);\n        }\n      } catch (error) {\n        rpcResp = _handleError(error);\n      }\n\n      // Validate the RPC response.\n      if (!isValidJsonResponse(rpcResp)) {\n        // Malformed response coming from the provider, report to user as an internal error.\n        rpcResp = _handleError(new InternalError(\"Internal error\"));\n      }\n\n      if (rpcReq !== undefined) {\n        rpcResp.id = rpcReq.id;\n      }\n\n      ws.send(JSON.stringify(rpcResp));\n    });\n\n    ws.on(\"close\", () => {\n      // Remove eth_subscribe listener.\n      this._provider.removeListener(\"notification\", listener);\n\n      // Clear any active subscriptions for the closed websocket connection.\n      isClosed = true;\n      subscriptions.forEach(async (subscriptionId) => {\n        await this._provider.request({\n          method: \"eth_unsubscribe\",\n          params: [subscriptionId],\n        });\n      });\n    });\n  };\n\n  private _sendEmptyResponse(res: ServerResponse) {\n    res.writeHead(200);\n    res.end();\n  }\n\n  private _setCorsHeaders(res: ServerResponse) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n\n  private _sendResponse(\n    res: ServerResponse,\n    rpcResp: JsonRpcResponse | JsonRpcResponse[]\n  ) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n\n  private async _handleSingleRequest(req: any): Promise<JsonRpcResponse> {\n    if (!isValidJsonRequest(req)) {\n      return _handleError(new InvalidRequestError(\"Invalid request\"));\n    }\n\n    const rpcReq: JsonRpcRequest = req;\n    let rpcResp: JsonRpcResponse | undefined;\n\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    }\n\n    // Validate the RPC response.\n    if (!isValidJsonResponse(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new InternalError(\"Internal error\"));\n    }\n\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n\n    return rpcResp;\n  }\n\n  private _handleRequest = async (\n    req: JsonRpcRequest\n  ): Promise<JsonRpcResponse> => {\n    const result = await this._provider.request({\n      method: req.method,\n      params: req.params,\n    });\n\n    return {\n      jsonrpc: \"2.0\",\n      id: req.id,\n      result,\n    };\n  };\n}\n\nconst _readJsonHttpRequest = async (req: IncomingMessage): Promise<any> => {\n  let json;\n\n  try {\n    const buf = await getRawBody(req);\n    const text = buf.toString();\n\n    json = JSON.parse(text);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return json;\n};\n\nconst _readWsRequest = (msg: string): JsonRpcRequest => {\n  let json: any;\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return json;\n};\n\nconst _handleError = (error: any): JsonRpcResponse => {\n  // extract the relevant fields from the error before wrapping it\n  let txHash: string | undefined;\n  let returnData: string | undefined;\n\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  }\n  if (error.data !== undefined) {\n    returnData = error.data;\n  }\n\n  // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n  if (!ProviderError.isProviderError(error)) {\n    error = new InternalError(error);\n  }\n\n  const response: FailedJsonRpcResponse = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message,\n    },\n  };\n\n  response.error.data = {\n    message: error.message,\n  };\n\n  if (txHash !== undefined) {\n    response.error.data.txHash = txHash;\n  }\n\n  if (returnData !== undefined) {\n    response.error.data.data = returnData;\n  }\n\n  return response;\n};\n"]},"metadata":{},"sourceType":"script"}