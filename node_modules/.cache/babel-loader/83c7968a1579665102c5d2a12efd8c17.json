{"ast":null,"code":"'use strict';\n\nconst {\n  types\n} = require('util');\nconst {\n  hasOwn,\n  toUSVString\n} = require('./util');\nconst webidl = {};\nwebidl.converters = {};\nwebidl.util = {};\nwebidl.errors = {};\n\n/**\n *\n * @param {{\n *   header: string\n *   message: string\n * }} message\n */\nwebidl.errors.exception = function (message) {\n  throw new TypeError(`${message.header}: ${message.message}`);\n};\n\n/**\n * Throw an error when conversion from one type to another has failed\n * @param {{\n *   prefix: string\n *   argument: string\n *   types: string[]\n * }} context\n */\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of';\n  const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(', ')}.`;\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  });\n};\n\n/**\n * Throw an error when an invalid argument is provided\n * @param {{\n *   prefix: string\n *   value: string\n *   type: string\n * }} context\n */\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  });\n};\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined':\n      return 'Undefined';\n    case 'boolean':\n      return 'Boolean';\n    case 'string':\n      return 'String';\n    case 'symbol':\n      return 'Symbol';\n    case 'number':\n      return 'Number';\n    case 'bigint':\n      return 'BigInt';\n    case 'function':\n    case 'object':\n      {\n        if (V === null) {\n          return 'Null';\n        }\n        return 'Object';\n      }\n  }\n};\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let upperBound;\n  let lowerBound;\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1;\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0;\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1;\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0;\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1;\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1;\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1;\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V);\n\n  // 5. If x is −0, then set x to +0.\n  if (Object.is(-0, x)) {\n    x = 0;\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n      webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${V} to an integer.`\n      });\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x);\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      });\n    }\n\n    // 4. Return x.\n    return x;\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound);\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x);\n    } else {\n      x = Math.ceil(x);\n    }\n\n    // 3. Return x.\n    return x;\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (Number.isNaN(x) || Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n    return 0;\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x);\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength);\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength);\n  }\n\n  // 12. Otherwise, return x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n));\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r;\n  }\n\n  // 3. Otherwise, return r.\n  return r;\n};\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return V => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      webidl.errors.exception({\n        header: 'Sequence',\n        message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n      });\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = V?.[Symbol.iterator]?.();\n    const seq = [];\n\n    // 3. If method is undefined, throw a TypeError.\n    if (method === undefined || typeof method.next !== 'function') {\n      webidl.errors.exception({\n        header: 'Sequence',\n        message: 'Object is not an iterator.'\n      });\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const {\n        done,\n        value\n      } = method.next();\n      if (done) {\n        break;\n      }\n      seq.push(converter(value));\n    }\n    return seq;\n  };\n};\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return V => {\n    const record = {};\n    const type = webidl.util.Type(V);\n    if (type === 'Undefined' || type === 'Null') {\n      return record;\n    }\n    if (type !== 'Object') {\n      webidl.errors.exception({\n        header: 'Record',\n        message: `Expected ${V} to be an Object type.`\n      });\n    }\n    for (let [key, value] of Object.entries(V)) {\n      key = keyConverter(key);\n      value = valueConverter(value);\n      record[key] = value;\n    }\n    return record;\n  };\n};\nwebidl.interfaceConverter = function (i) {\n  return function (V) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (opts.strict !== false && !(V instanceof i)) {\n      webidl.errors.exception({\n        header: i.name,\n        message: `Expected ${V} to be an instance of ${i.name}.`\n      });\n    }\n    return V;\n  };\n};\n\n/**\n * @param {{\n *   key: string,\n *   defaultValue?: any,\n *   required?: boolean,\n *   converter: (...args: unknown[]) => unknown,\n *   allowedValues?: any[]\n * }[]} converters\n * @returns\n */\nwebidl.dictionaryConverter = function (converters) {\n  return dictionary => {\n    const type = webidl.util.Type(dictionary);\n    const dict = {};\n    if (type !== 'Null' && type !== 'Undefined' && type !== 'Object') {\n      webidl.errors.exception({\n        header: 'Dictionary',\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      });\n    }\n    for (const options of converters) {\n      const {\n        key,\n        defaultValue,\n        required,\n        converter\n      } = options;\n      if (required === true) {\n        if (!hasOwn(dictionary, key)) {\n          webidl.errors.exception({\n            header: 'Dictionary',\n            message: `Missing required key \"${key}\".`\n          });\n        }\n      }\n      let value = dictionary[key];\n      const hasDefault = hasOwn(options, 'defaultValue');\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value = value ?? defaultValue;\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value);\n        if (options.allowedValues && !options.allowedValues.includes(value)) {\n          webidl.errors.exception({\n            header: 'Dictionary',\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          });\n        }\n        dict[key] = value;\n      }\n    }\n    return dict;\n  };\n};\nwebidl.nullableConverter = function (converter) {\n  return V => {\n    if (V === null) {\n      return V;\n    }\n    return converter(V);\n  };\n};\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts.legacyNullToEmptyString) {\n    return '';\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw new TypeError('Could not convert argument of type symbol to string.');\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V);\n};\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V);\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    const charCode = x.charCodeAt(index);\n    if (charCode > 255) {\n      throw new TypeError('Cannot convert argument to a ByteString because the character at' + `index ${index} has a value of ${charCode} which is greater than 255.`);\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-USVString\n// TODO: ensure that util.toUSVString follows webidl spec\nwebidl.converters.USVString = toUSVString;\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V);\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V;\n};\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, opts) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', opts);\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned');\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x;\n};\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (webidl.util.Type(V) !== 'Object' || !types.isAnyArrayBuffer(V)) {\n    webidl.errors.conversionFailed({\n      prefix: `${V}`,\n      argument: `${V}`,\n      types: ['ArrayBuffer']\n    });\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal.\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V;\n};\nwebidl.converters.TypedArray = function (V, T) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n    webidl.errors.conversionFailed({\n      prefix: `${T.name}`,\n      argument: `${V}`,\n      types: [T.name]\n    });\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable array buffers are currently a proposal\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V;\n};\nwebidl.converters.DataView = function (V) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    webidl.errors.exception({\n      header: 'DataView',\n      message: 'Object is not a DataView.'\n    });\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V;\n};\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, opts);\n  }\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor);\n  }\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, opts);\n  }\n  throw new TypeError(`Could not convert ${V} to a BufferSource.`);\n};\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(webidl.converters.ByteString);\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(webidl.converters['sequence<ByteString>']);\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);\nmodule.exports = {\n  webidl\n};","map":{"version":3,"names":["types","require","hasOwn","toUSVString","webidl","converters","util","errors","exception","message","TypeError","header","conversionFailed","context","plural","length","argument","join","prefix","invalidArgument","value","type","Type","V","ConvertToInt","bitLength","signedness","opts","upperBound","lowerBound","Math","pow","x","Number","Object","is","enforceRange","isNaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","IntegerPart","clamp","min","max","floor","ceil","n","r","abs","sequenceConverter","converter","method","Symbol","iterator","seq","undefined","next","done","push","recordConverter","keyConverter","valueConverter","record","key","entries","interfaceConverter","i","strict","name","dictionaryConverter","dictionary","dict","options","defaultValue","required","hasDefault","allowedValues","includes","nullableConverter","DOMString","legacyNullToEmptyString","String","ByteString","index","charCode","charCodeAt","USVString","boolean","Boolean","any","ArrayBuffer","isAnyArrayBuffer","allowShared","isSharedArrayBuffer","TypedArray","T","isTypedArray","constructor","buffer","DataView","isDataView","BufferSource","module","exports"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/undici/lib/fetch/webidl.js"],"sourcesContent":["'use strict'\n\nconst { types } = require('util')\nconst { hasOwn, toUSVString } = require('./util')\n\nconst webidl = {}\nwebidl.converters = {}\nwebidl.util = {}\nwebidl.errors = {}\n\n/**\n *\n * @param {{\n *   header: string\n *   message: string\n * }} message\n */\nwebidl.errors.exception = function (message) {\n  throw new TypeError(`${message.header}: ${message.message}`)\n}\n\n/**\n * Throw an error when conversion from one type to another has failed\n * @param {{\n *   prefix: string\n *   argument: string\n *   types: string[]\n * }} context\n */\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of'\n  const message =\n    `${context.argument} could not be converted to` +\n    `${plural}: ${context.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  })\n}\n\n/**\n * Throw an error when an invalid argument is provided\n * @param {{\n *   prefix: string\n *   value: string\n *   type: string\n * }} context\n */\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return 'Undefined'\n    case 'boolean': return 'Boolean'\n    case 'string': return 'String'\n    case 'symbol': return 'Symbol'\n    case 'number': return 'Number'\n    case 'bigint': return 'BigInt'\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return 'Null'\n      }\n\n      return 'Object'\n    }\n  }\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is −0, then set x to +0.\n  if (Object.is(-0, x)) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${V} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (\n    Number.isNaN(x) ||\n    Object.is(0, x) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      webidl.errors.exception({\n        header: 'Sequence',\n        message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = V?.[Symbol.iterator]?.()\n    const seq = []\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      webidl.errors.exception({\n        header: 'Sequence',\n        message: 'Object is not an iterator.'\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value))\n    }\n\n    return seq\n  }\n}\n\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (V) => {\n    const record = {}\n    const type = webidl.util.Type(V)\n\n    if (type === 'Undefined' || type === 'Null') {\n      return record\n    }\n\n    if (type !== 'Object') {\n      webidl.errors.exception({\n        header: 'Record',\n        message: `Expected ${V} to be an Object type.`\n      })\n    }\n\n    for (let [key, value] of Object.entries(V)) {\n      key = keyConverter(key)\n      value = valueConverter(value)\n\n      record[key] = value\n    }\n\n    return record\n  }\n}\n\nwebidl.interfaceConverter = function (i) {\n  return (V, opts = {}) => {\n    if (opts.strict !== false && !(V instanceof i)) {\n      webidl.errors.exception({\n        header: i.name,\n        message: `Expected ${V} to be an instance of ${i.name}.`\n      })\n    }\n\n    return V\n  }\n}\n\n/**\n * @param {{\n *   key: string,\n *   defaultValue?: any,\n *   required?: boolean,\n *   converter: (...args: unknown[]) => unknown,\n *   allowedValues?: any[]\n * }[]} converters\n * @returns\n */\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary) => {\n    const type = webidl.util.Type(dictionary)\n    const dict = {}\n\n    if (type !== 'Null' && type !== 'Undefined' && type !== 'Object') {\n      webidl.errors.exception({\n        header: 'Dictionary',\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (!hasOwn(dictionary, key)) {\n          webidl.errors.exception({\n            header: 'Dictionary',\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary[key]\n      const hasDefault = hasOwn(options, 'defaultValue')\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value = value ?? defaultValue\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          webidl.errors.exception({\n            header: 'Dictionary',\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V)\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, opts = {}) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts.legacyNullToEmptyString) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw new TypeError('Could not convert argument of type symbol to string.')\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    const charCode = x.charCodeAt(index)\n\n    if (charCode > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at' +\n        `index ${index} has a value of ${charCode} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-USVString\n// TODO: ensure that util.toUSVString follows webidl spec\nwebidl.converters.USVString = toUSVString\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, opts) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', opts)\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned')\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isAnyArrayBuffer(V)\n  ) {\n    webidl.errors.conversionFailed({\n      prefix: `${V}`,\n      argument: `${V}`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal.\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\nwebidl.converters.TypedArray = function (V, T, opts = {}) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    webidl.errors.conversionFailed({\n      prefix: `${T.name}`,\n      argument: `${V}`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable array buffers are currently a proposal\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters.DataView = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    webidl.errors.exception({\n      header: 'DataView',\n      message: 'Object is not a DataView.'\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, opts = {}) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, opts)\n  }\n\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor)\n  }\n\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, opts)\n  }\n\n  throw new TypeError(`Could not convert ${V} to a BufferSource.`)\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nmodule.exports = {\n  webidl\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}