{"ast":null,"code":"'use strict';\n\nconst {\n  Headers,\n  HeadersList,\n  fill\n} = require('./headers');\nconst {\n  extractBody,\n  cloneBody,\n  mixinBody\n} = require('./body');\nconst util = require('../core/util');\nconst {\n  kEnumerableProperty\n} = util;\nconst {\n  responseURL,\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike\n} = require('./util');\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  DOMException\n} = require('./constants');\nconst {\n  kState,\n  kHeaders,\n  kGuard,\n  kRealm\n} = require('./symbols');\nconst {\n  webidl\n} = require('./webidl');\nconst {\n  FormData\n} = require('./formdata');\nconst {\n  getGlobalOrigin\n} = require('./global');\nconst {\n  kHeadersList\n} = require('../core/symbols');\nconst assert = require('assert');\nconst {\n  types\n} = require('util');\nconst ReadableStream = globalThis.ReadableStream || require('stream/web').ReadableStream;\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error() {\n    // TODO\n    const relevantRealm = {\n      settingsObject: {}\n    };\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response();\n    responseObject[kState] = makeNetworkError();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n    return responseObject;\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json(data) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (arguments.length === 0) {\n      throw new TypeError('Failed to execute \\'json\\' on \\'Response\\': 1 argument required, but 0 present.');\n    }\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init);\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = new TextEncoder('utf-8').encode(serializeJavascriptValueToJSONString(data));\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes);\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const relevantRealm = {\n      settingsObject: {}\n    };\n    const responseObject = new Response();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kGuard] = 'response';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, {\n      body: body[0],\n      type: 'application/json'\n    });\n\n    // 5. Return responseObject.\n    return responseObject;\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect(url) {\n    let status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 302;\n    const relevantRealm = {\n      settingsObject: {}\n    };\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`);\n    }\n    url = webidl.converters.USVString(url);\n    status = webidl.converters['unsigned short'](status);\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL;\n    try {\n      parsedURL = new URL(url, getGlobalOrigin());\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      });\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code');\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status;\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    // TODO: isomorphic encoded?\n    const value = parsedURL.toString();\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.append('location', value);\n\n    // 8. Return responseObject.\n    return responseObject;\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor() {\n    let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body);\n    }\n    init = webidl.converters.ResponseInit(init);\n\n    // TODO\n    this[kRealm] = {\n      settingsObject: {}\n    };\n\n    // 1. Set this’s response to a new response.\n    this[kState] = makeResponse({});\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers();\n    this[kHeaders][kGuard] = 'response';\n    this[kHeaders][kHeadersList] = this[kState].headersList;\n    this[kHeaders][kRealm] = this[kRealm];\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null;\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body);\n      bodyWithType = {\n        body: extractedBody,\n        type\n      };\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType);\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type;\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    let url = responseURL(this[kState]);\n    if (url == null) {\n      return '';\n    }\n    if (url.hash) {\n      url = new URL(url);\n      url.hash = '';\n    }\n    return url.toString();\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1;\n  }\n\n  // Returns response’s status.\n  get status() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status;\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299;\n  }\n\n  // Returns response’s status message.\n  get statusText() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText;\n  }\n\n  // Returns response’s headers as Headers.\n  get headers() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders];\n  }\n\n  // Returns a clone of response.\n  clone() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || this.body && this.body.locked) {\n      webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      });\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState]);\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response();\n    clonedResponseObject[kState] = clonedResponse;\n    clonedResponseObject[kRealm] = this[kRealm];\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n    return clonedResponseObject;\n  }\n}\nmixinBody(Response);\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty\n});\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse(response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(cloneResponse(response.internalResponse), response.type);\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({\n    ...response,\n    body: null\n  });\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body);\n  }\n\n  // 4. Return newResponse.\n  return newResponse;\n}\nfunction makeResponse(init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  };\n}\nfunction makeNetworkError(reason) {\n  const isError = isErrorLike(reason);\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError ? reason : new Error(reason ? String(reason) : reason, {\n      cause: isError ? reason : undefined\n    }),\n    aborted: reason && reason.name === 'AbortError'\n  });\n}\nfunction makeFilteredResponse(response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  };\n  return new Proxy(response, {\n    get(target, p) {\n      return p in state ? state[p] : target[p];\n    },\n    set(target, p, value) {\n      assert(!(p in state));\n      target[p] = value;\n      return true;\n    }\n  });\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse(response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    });\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    });\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    });\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    });\n  } else {\n    assert(false);\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError(fetchParams) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams));\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams) ? makeNetworkError(new DOMException('The operation was aborted.', 'AbortError')) : makeNetworkError(fetchParams.controller.terminated.reason);\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse(response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText');\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status;\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText;\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kState].headersList, init.headers);\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      webidl.errors.exception({\n        header: 'Response constructor',\n        message: 'Invalid response status code.'\n      });\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body;\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.has('Content-Type')) {\n      response[kState].headersList.append('content-type', body.type);\n    }\n  }\n}\nwebidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);\nwebidl.converters.FormData = webidl.interfaceConverter(FormData);\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V);\n  }\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, {\n      strict: false\n    });\n  }\n  if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {\n    return webidl.converters.BufferSource(V);\n  }\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, {\n      strict: false\n    });\n  }\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V);\n  }\n  return webidl.converters.DOMString(V);\n};\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V);\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V;\n  }\n  return webidl.converters.XMLHttpRequestBodyInit(V);\n};\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([{\n  key: 'status',\n  converter: webidl.converters['unsigned short'],\n  defaultValue: 200\n}, {\n  key: 'statusText',\n  converter: webidl.converters.ByteString,\n  defaultValue: ''\n}, {\n  key: 'headers',\n  converter: webidl.converters.HeadersInit\n}]);\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response\n};","map":{"version":3,"names":["Headers","HeadersList","fill","require","extractBody","cloneBody","mixinBody","util","kEnumerableProperty","responseURL","isValidReasonPhrase","isCancelled","isAborted","isBlobLike","serializeJavascriptValueToJSONString","isErrorLike","redirectStatus","nullBodyStatus","DOMException","kState","kHeaders","kGuard","kRealm","webidl","FormData","getGlobalOrigin","kHeadersList","assert","types","ReadableStream","globalThis","Response","error","relevantRealm","settingsObject","responseObject","makeNetworkError","headersList","json","data","init","arguments","length","TypeError","converters","ResponseInit","bytes","TextEncoder","encode","body","initializeResponse","type","redirect","url","status","USVString","parsedURL","URL","err","Object","assign","cause","includes","RangeError","value","toString","append","constructor","BodyInit","makeResponse","bodyWithType","extractedBody","Symbol","toStringTag","name","hash","redirected","urlList","ok","statusText","headers","clone","bodyUsed","locked","errors","exception","header","message","clonedResponse","cloneResponse","clonedResponseObject","defineProperties","prototype","response","internalResponse","filterResponse","newResponse","aborted","rangeRequested","timingAllowPassed","requestIncludesCredentials","timingInfo","cacheState","reason","isError","Error","String","undefined","makeFilteredResponse","state","Proxy","get","target","p","set","freeze","makeAppropriateNetworkError","fetchParams","controller","terminated","has","interfaceConverter","URLSearchParams","XMLHttpRequestBodyInit","V","Blob","strict","isAnyArrayBuffer","isTypedArray","isDataView","BufferSource","isFormDataLike","DOMString","asyncIterator","dictionaryConverter","key","converter","defaultValue","ByteString","HeadersInit","module","exports"],"sources":["/home/jagadeshronanki/projects/millow/node_modules/undici/lib/fetch/response.js"],"sourcesContent":["'use strict'\n\nconst { Headers, HeadersList, fill } = require('./headers')\nconst { extractBody, cloneBody, mixinBody } = require('./body')\nconst util = require('../core/util')\nconst { kEnumerableProperty } = util\nconst {\n  responseURL,\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike\n} = require('./util')\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  DOMException\n} = require('./constants')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { FormData } = require('./formdata')\nconst { getGlobalOrigin } = require('./global')\nconst { kHeadersList } = require('../core/symbols')\nconst assert = require('assert')\nconst { types } = require('util')\n\nconst ReadableStream = globalThis.ReadableStream || require('stream/web').ReadableStream\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // TODO\n    const relevantRealm = { settingsObject: {} }\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response()\n    responseObject[kState] = makeNetworkError()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data, init = {}) {\n    if (arguments.length === 0) {\n      throw new TypeError(\n        'Failed to execute \\'json\\' on \\'Response\\': 1 argument required, but 0 present.'\n      )\n    }\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = new TextEncoder('utf-8').encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const relevantRealm = { settingsObject: {} }\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'response'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    const relevantRealm = { settingsObject: {} }\n\n    if (arguments.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`\n      )\n    }\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, getGlobalOrigin())\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code')\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    // TODO: isomorphic encoded?\n    const value = parsedURL.toString()\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.append('location', value)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = {}) {\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body)\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'response'\n    this[kHeaders][kHeadersList] = this[kState].headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  get [Symbol.toStringTag] () {\n    return this.constructor.name\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    let url = responseURL(this[kState])\n\n    if (url == null) {\n      return ''\n    }\n\n    if (url.hash) {\n      url = new URL(url)\n      url.hash = ''\n    }\n\n    return url.toString()\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns a clone of response.\n  clone () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response()\n    clonedResponseObject[kState] = clonedResponse\n    clonedResponseObject[kRealm] = this[kRealm]\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    return clonedResponseObject\n  }\n}\n\nmixinBody(Response)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason, {\n        cause: isError ? reason : undefined\n      }),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(new DOMException('The operation was aborted.', 'AbortError'))\n    : makeNetworkError(fetchParams.controller.terminated.reason)\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kState].headersList, init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      webidl.errors.exception({\n        header: 'Response constructor',\n        message: 'Invalid response status code.'\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.has('Content-Type')) {\n      response[kState].headersList.append('content-type', body.type)\n    }\n  }\n}\n\nwebidl.converters.ReadableStream = webidl.interfaceConverter(\n  ReadableStream\n)\n\nwebidl.converters.FormData = webidl.interfaceConverter(\n  FormData\n)\n\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(\n  URLSearchParams\n)\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, { strict: false })\n  }\n\n  if (\n    types.isAnyArrayBuffer(V) ||\n    types.isTypedArray(V) ||\n    types.isDataView(V)\n  ) {\n    return webidl.converters.BufferSource(V)\n  }\n\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, { strict: false })\n  }\n\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V)\n  }\n\n  return webidl.converters.DOMString(V)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V)\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA,OAAO;EAAEC,WAAW;EAAEC;AAAK,CAAC,GAAGC,OAAO,CAAC,WAAW,CAAC;AAC3D,MAAM;EAAEC,WAAW;EAAEC,SAAS;EAAEC;AAAU,CAAC,GAAGH,OAAO,CAAC,QAAQ,CAAC;AAC/D,MAAMI,IAAI,GAAGJ,OAAO,CAAC,cAAc,CAAC;AACpC,MAAM;EAAEK;AAAoB,CAAC,GAAGD,IAAI;AACpC,MAAM;EACJE,WAAW;EACXC,mBAAmB;EACnBC,WAAW;EACXC,SAAS;EACTC,UAAU;EACVC,oCAAoC;EACpCC;AACF,CAAC,GAAGZ,OAAO,CAAC,QAAQ,CAAC;AACrB,MAAM;EACJa,cAAc;EACdC,cAAc;EACdC;AACF,CAAC,GAAGf,OAAO,CAAC,aAAa,CAAC;AAC1B,MAAM;EAAEgB,MAAM;EAAEC,QAAQ;EAAEC,MAAM;EAAEC;AAAO,CAAC,GAAGnB,OAAO,CAAC,WAAW,CAAC;AACjE,MAAM;EAAEoB;AAAO,CAAC,GAAGpB,OAAO,CAAC,UAAU,CAAC;AACtC,MAAM;EAAEqB;AAAS,CAAC,GAAGrB,OAAO,CAAC,YAAY,CAAC;AAC1C,MAAM;EAAEsB;AAAgB,CAAC,GAAGtB,OAAO,CAAC,UAAU,CAAC;AAC/C,MAAM;EAAEuB;AAAa,CAAC,GAAGvB,OAAO,CAAC,iBAAiB,CAAC;AACnD,MAAMwB,MAAM,GAAGxB,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAM;EAAEyB;AAAM,CAAC,GAAGzB,OAAO,CAAC,MAAM,CAAC;AAEjC,MAAM0B,cAAc,GAAGC,UAAU,CAACD,cAAc,IAAI1B,OAAO,CAAC,YAAY,CAAC,CAAC0B,cAAc;;AAExF;AACA,MAAME,QAAQ,CAAC;EACb;EACA,OAAOC,KAAK,GAAI;IACd;IACA,MAAMC,aAAa,GAAG;MAAEC,cAAc,EAAE,CAAC;IAAE,CAAC;;IAE5C;IACA;IACA;IACA,MAAMC,cAAc,GAAG,IAAIJ,QAAQ,EAAE;IACrCI,cAAc,CAAChB,MAAM,CAAC,GAAGiB,gBAAgB,EAAE;IAC3CD,cAAc,CAACb,MAAM,CAAC,GAAGW,aAAa;IACtCE,cAAc,CAACf,QAAQ,CAAC,CAACM,YAAY,CAAC,GAAGS,cAAc,CAAChB,MAAM,CAAC,CAACkB,WAAW;IAC3EF,cAAc,CAACf,QAAQ,CAAC,CAACC,MAAM,CAAC,GAAG,WAAW;IAC9Cc,cAAc,CAACf,QAAQ,CAAC,CAACE,MAAM,CAAC,GAAGW,aAAa;IAChD,OAAOE,cAAc;EACvB;;EAEA;EACA,OAAOG,IAAI,CAAEC,IAAI,EAAa;IAAA,IAAXC,IAAI,uEAAG,CAAC,CAAC;IAC1B,IAAIC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MAC1B,MAAM,IAAIC,SAAS,CACjB,iFAAiF,CAClF;IACH;IAEA,IAAIH,IAAI,KAAK,IAAI,EAAE;MACjBA,IAAI,GAAGjB,MAAM,CAACqB,UAAU,CAACC,YAAY,CAACL,IAAI,CAAC;IAC7C;;IAEA;IACA,MAAMM,KAAK,GAAG,IAAIC,WAAW,CAAC,OAAO,CAAC,CAACC,MAAM,CAC3ClC,oCAAoC,CAACyB,IAAI,CAAC,CAC3C;;IAED;IACA,MAAMU,IAAI,GAAG7C,WAAW,CAAC0C,KAAK,CAAC;;IAE/B;IACA;IACA,MAAMb,aAAa,GAAG;MAAEC,cAAc,EAAE,CAAC;IAAE,CAAC;IAC5C,MAAMC,cAAc,GAAG,IAAIJ,QAAQ,EAAE;IACrCI,cAAc,CAACb,MAAM,CAAC,GAAGW,aAAa;IACtCE,cAAc,CAACf,QAAQ,CAAC,CAACC,MAAM,CAAC,GAAG,UAAU;IAC7Cc,cAAc,CAACf,QAAQ,CAAC,CAACE,MAAM,CAAC,GAAGW,aAAa;;IAEhD;IACAiB,kBAAkB,CAACf,cAAc,EAAEK,IAAI,EAAE;MAAES,IAAI,EAAEA,IAAI,CAAC,CAAC,CAAC;MAAEE,IAAI,EAAE;IAAmB,CAAC,CAAC;;IAErF;IACA,OAAOhB,cAAc;EACvB;;EAEA;EACA,OAAOiB,QAAQ,CAAEC,GAAG,EAAgB;IAAA,IAAdC,MAAM,uEAAG,GAAG;IAChC,MAAMrB,aAAa,GAAG;MAAEC,cAAc,EAAE,CAAC;IAAE,CAAC;IAE5C,IAAIO,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;MACxB,MAAM,IAAIC,SAAS,CAChB,6EAA4EF,SAAS,CAACC,MAAO,WAAU,CACzG;IACH;IAEAW,GAAG,GAAG9B,MAAM,CAACqB,UAAU,CAACW,SAAS,CAACF,GAAG,CAAC;IACtCC,MAAM,GAAG/B,MAAM,CAACqB,UAAU,CAAC,gBAAgB,CAAC,CAACU,MAAM,CAAC;;IAEpD;IACA;IACA;IACA;IACA,IAAIE,SAAS;IACb,IAAI;MACFA,SAAS,GAAG,IAAIC,GAAG,CAACJ,GAAG,EAAE5B,eAAe,EAAE,CAAC;IAC7C,CAAC,CAAC,OAAOiC,GAAG,EAAE;MACZ,MAAMC,MAAM,CAACC,MAAM,CAAC,IAAIjB,SAAS,CAAC,2BAA2B,GAAGU,GAAG,CAAC,EAAE;QACpEQ,KAAK,EAAEH;MACT,CAAC,CAAC;IACJ;;IAEA;IACA,IAAI,CAAC1C,cAAc,CAAC8C,QAAQ,CAACR,MAAM,CAAC,EAAE;MACpC,MAAM,IAAIS,UAAU,CAAC,qBAAqB,CAAC;IAC7C;;IAEA;IACA;IACA,MAAM5B,cAAc,GAAG,IAAIJ,QAAQ,EAAE;IACrCI,cAAc,CAACb,MAAM,CAAC,GAAGW,aAAa;IACtCE,cAAc,CAACf,QAAQ,CAAC,CAACC,MAAM,CAAC,GAAG,WAAW;IAC9Cc,cAAc,CAACf,QAAQ,CAAC,CAACE,MAAM,CAAC,GAAGW,aAAa;;IAEhD;IACAE,cAAc,CAAChB,MAAM,CAAC,CAACmC,MAAM,GAAGA,MAAM;;IAEtC;IACA;IACA,MAAMU,KAAK,GAAGR,SAAS,CAACS,QAAQ,EAAE;;IAElC;IACA9B,cAAc,CAAChB,MAAM,CAAC,CAACkB,WAAW,CAAC6B,MAAM,CAAC,UAAU,EAAEF,KAAK,CAAC;;IAE5D;IACA,OAAO7B,cAAc;EACvB;;EAEA;EACAgC,WAAW,GAA0B;IAAA,IAAxBlB,IAAI,uEAAG,IAAI;IAAA,IAAET,IAAI,uEAAG,CAAC,CAAC;IACjC,IAAIS,IAAI,KAAK,IAAI,EAAE;MACjBA,IAAI,GAAG1B,MAAM,CAACqB,UAAU,CAACwB,QAAQ,CAACnB,IAAI,CAAC;IACzC;IAEAT,IAAI,GAAGjB,MAAM,CAACqB,UAAU,CAACC,YAAY,CAACL,IAAI,CAAC;;IAE3C;IACA,IAAI,CAAClB,MAAM,CAAC,GAAG;MAAEY,cAAc,EAAE,CAAC;IAAE,CAAC;;IAErC;IACA,IAAI,CAACf,MAAM,CAAC,GAAGkD,YAAY,CAAC,CAAC,CAAC,CAAC;;IAE/B;IACA;IACA;IACA,IAAI,CAACjD,QAAQ,CAAC,GAAG,IAAIpB,OAAO,EAAE;IAC9B,IAAI,CAACoB,QAAQ,CAAC,CAACC,MAAM,CAAC,GAAG,UAAU;IACnC,IAAI,CAACD,QAAQ,CAAC,CAACM,YAAY,CAAC,GAAG,IAAI,CAACP,MAAM,CAAC,CAACkB,WAAW;IACvD,IAAI,CAACjB,QAAQ,CAAC,CAACE,MAAM,CAAC,GAAG,IAAI,CAACA,MAAM,CAAC;;IAErC;IACA,IAAIgD,YAAY,GAAG,IAAI;;IAEvB;IACA,IAAIrB,IAAI,IAAI,IAAI,EAAE;MAChB,MAAM,CAACsB,aAAa,EAAEpB,IAAI,CAAC,GAAG/C,WAAW,CAAC6C,IAAI,CAAC;MAC/CqB,YAAY,GAAG;QAAErB,IAAI,EAAEsB,aAAa;QAAEpB;MAAK,CAAC;IAC9C;;IAEA;IACAD,kBAAkB,CAAC,IAAI,EAAEV,IAAI,EAAE8B,YAAY,CAAC;EAC9C;EAEA,KAAKE,MAAM,CAACC,WAAW,IAAK;IAC1B,OAAO,IAAI,CAACN,WAAW,CAACO,IAAI;EAC9B;;EAEA;EACA,IAAIvB,IAAI,GAAI;IACV,IAAI,EAAE,IAAI,YAAYpB,QAAQ,CAAC,EAAE;MAC/B,MAAM,IAAIY,SAAS,CAAC,oBAAoB,CAAC;IAC3C;;IAEA;IACA,OAAO,IAAI,CAACxB,MAAM,CAAC,CAACgC,IAAI;EAC1B;;EAEA;EACA,IAAIE,GAAG,GAAI;IACT,IAAI,EAAE,IAAI,YAAYtB,QAAQ,CAAC,EAAE;MAC/B,MAAM,IAAIY,SAAS,CAAC,oBAAoB,CAAC;IAC3C;;IAEA;IACA;IACA;IACA,IAAIU,GAAG,GAAG5C,WAAW,CAAC,IAAI,CAACU,MAAM,CAAC,CAAC;IAEnC,IAAIkC,GAAG,IAAI,IAAI,EAAE;MACf,OAAO,EAAE;IACX;IAEA,IAAIA,GAAG,CAACsB,IAAI,EAAE;MACZtB,GAAG,GAAG,IAAII,GAAG,CAACJ,GAAG,CAAC;MAClBA,GAAG,CAACsB,IAAI,GAAG,EAAE;IACf;IAEA,OAAOtB,GAAG,CAACY,QAAQ,EAAE;EACvB;;EAEA;EACA,IAAIW,UAAU,GAAI;IAChB,IAAI,EAAE,IAAI,YAAY7C,QAAQ,CAAC,EAAE;MAC/B,MAAM,IAAIY,SAAS,CAAC,oBAAoB,CAAC;IAC3C;;IAEA;IACA;IACA,OAAO,IAAI,CAACxB,MAAM,CAAC,CAAC0D,OAAO,CAACnC,MAAM,GAAG,CAAC;EACxC;;EAEA;EACA,IAAIY,MAAM,GAAI;IACZ,IAAI,EAAE,IAAI,YAAYvB,QAAQ,CAAC,EAAE;MAC/B,MAAM,IAAIY,SAAS,CAAC,oBAAoB,CAAC;IAC3C;;IAEA;IACA,OAAO,IAAI,CAACxB,MAAM,CAAC,CAACmC,MAAM;EAC5B;;EAEA;EACA,IAAIwB,EAAE,GAAI;IACR,IAAI,EAAE,IAAI,YAAY/C,QAAQ,CAAC,EAAE;MAC/B,MAAM,IAAIY,SAAS,CAAC,oBAAoB,CAAC;IAC3C;;IAEA;IACA;IACA,OAAO,IAAI,CAACxB,MAAM,CAAC,CAACmC,MAAM,IAAI,GAAG,IAAI,IAAI,CAACnC,MAAM,CAAC,CAACmC,MAAM,IAAI,GAAG;EACjE;;EAEA;EACA,IAAIyB,UAAU,GAAI;IAChB,IAAI,EAAE,IAAI,YAAYhD,QAAQ,CAAC,EAAE;MAC/B,MAAM,IAAIY,SAAS,CAAC,oBAAoB,CAAC;IAC3C;;IAEA;IACA;IACA,OAAO,IAAI,CAACxB,MAAM,CAAC,CAAC4D,UAAU;EAChC;;EAEA;EACA,IAAIC,OAAO,GAAI;IACb,IAAI,EAAE,IAAI,YAAYjD,QAAQ,CAAC,EAAE;MAC/B,MAAM,IAAIY,SAAS,CAAC,oBAAoB,CAAC;IAC3C;;IAEA;IACA,OAAO,IAAI,CAACvB,QAAQ,CAAC;EACvB;;EAEA;EACA6D,KAAK,GAAI;IACP,IAAI,EAAE,IAAI,YAAYlD,QAAQ,CAAC,EAAE;MAC/B,MAAM,IAAIY,SAAS,CAAC,oBAAoB,CAAC;IAC3C;;IAEA;IACA,IAAI,IAAI,CAACuC,QAAQ,IAAK,IAAI,CAACjC,IAAI,IAAI,IAAI,CAACA,IAAI,CAACkC,MAAO,EAAE;MACpD5D,MAAM,CAAC6D,MAAM,CAACC,SAAS,CAAC;QACtBC,MAAM,EAAE,gBAAgB;QACxBC,OAAO,EAAE;MACX,CAAC,CAAC;IACJ;;IAEA;IACA,MAAMC,cAAc,GAAGC,aAAa,CAAC,IAAI,CAACtE,MAAM,CAAC,CAAC;;IAElD;IACA;IACA,MAAMuE,oBAAoB,GAAG,IAAI3D,QAAQ,EAAE;IAC3C2D,oBAAoB,CAACvE,MAAM,CAAC,GAAGqE,cAAc;IAC7CE,oBAAoB,CAACpE,MAAM,CAAC,GAAG,IAAI,CAACA,MAAM,CAAC;IAC3CoE,oBAAoB,CAACtE,QAAQ,CAAC,CAACM,YAAY,CAAC,GAAG8D,cAAc,CAACnD,WAAW;IACzEqD,oBAAoB,CAACtE,QAAQ,CAAC,CAACC,MAAM,CAAC,GAAG,IAAI,CAACD,QAAQ,CAAC,CAACC,MAAM,CAAC;IAC/DqE,oBAAoB,CAACtE,QAAQ,CAAC,CAACE,MAAM,CAAC,GAAG,IAAI,CAACF,QAAQ,CAAC,CAACE,MAAM,CAAC;IAE/D,OAAOoE,oBAAoB;EAC7B;AACF;AAEApF,SAAS,CAACyB,QAAQ,CAAC;AAEnB4B,MAAM,CAACgC,gBAAgB,CAAC5D,QAAQ,CAAC6D,SAAS,EAAE;EAC1CzC,IAAI,EAAE3C,mBAAmB;EACzB6C,GAAG,EAAE7C,mBAAmB;EACxB8C,MAAM,EAAE9C,mBAAmB;EAC3BsE,EAAE,EAAEtE,mBAAmB;EACvBoE,UAAU,EAAEpE,mBAAmB;EAC/BuE,UAAU,EAAEvE,mBAAmB;EAC/BwE,OAAO,EAAExE,mBAAmB;EAC5ByE,KAAK,EAAEzE;AACT,CAAC,CAAC;;AAEF;AACA,SAASiF,aAAa,CAAEI,QAAQ,EAAE;EAChC;;EAEA;EACA;EACA;EACA,IAAIA,QAAQ,CAACC,gBAAgB,EAAE;IAC7B,OAAOC,cAAc,CACnBN,aAAa,CAACI,QAAQ,CAACC,gBAAgB,CAAC,EACxCD,QAAQ,CAAC1C,IAAI,CACd;EACH;;EAEA;EACA,MAAM6C,WAAW,GAAG3B,YAAY,CAAC;IAAE,GAAGwB,QAAQ;IAAE5C,IAAI,EAAE;EAAK,CAAC,CAAC;;EAE7D;EACA;EACA,IAAI4C,QAAQ,CAAC5C,IAAI,IAAI,IAAI,EAAE;IACzB+C,WAAW,CAAC/C,IAAI,GAAG5C,SAAS,CAACwF,QAAQ,CAAC5C,IAAI,CAAC;EAC7C;;EAEA;EACA,OAAO+C,WAAW;AACpB;AAEA,SAAS3B,YAAY,CAAE7B,IAAI,EAAE;EAC3B,OAAO;IACLyD,OAAO,EAAE,KAAK;IACdC,cAAc,EAAE,KAAK;IACrBC,iBAAiB,EAAE,KAAK;IACxBC,0BAA0B,EAAE,KAAK;IACjCjD,IAAI,EAAE,SAAS;IACfG,MAAM,EAAE,GAAG;IACX+C,UAAU,EAAE,IAAI;IAChBC,UAAU,EAAE,EAAE;IACdvB,UAAU,EAAE,EAAE;IACd,GAAGvC,IAAI;IACPH,WAAW,EAAEG,IAAI,CAACH,WAAW,GACzB,IAAIpC,WAAW,CAACuC,IAAI,CAACH,WAAW,CAAC,GACjC,IAAIpC,WAAW,EAAE;IACrB4E,OAAO,EAAErC,IAAI,CAACqC,OAAO,GAAG,CAAC,GAAGrC,IAAI,CAACqC,OAAO,CAAC,GAAG;EAC9C,CAAC;AACH;AAEA,SAASzC,gBAAgB,CAAEmE,MAAM,EAAE;EACjC,MAAMC,OAAO,GAAGzF,WAAW,CAACwF,MAAM,CAAC;EACnC,OAAOlC,YAAY,CAAC;IAClBlB,IAAI,EAAE,OAAO;IACbG,MAAM,EAAE,CAAC;IACTtB,KAAK,EAAEwE,OAAO,GACVD,MAAM,GACN,IAAIE,KAAK,CAACF,MAAM,GAAGG,MAAM,CAACH,MAAM,CAAC,GAAGA,MAAM,EAAE;MAC5C1C,KAAK,EAAE2C,OAAO,GAAGD,MAAM,GAAGI;IAC5B,CAAC,CAAC;IACJV,OAAO,EAAEM,MAAM,IAAIA,MAAM,CAAC7B,IAAI,KAAK;EACrC,CAAC,CAAC;AACJ;AAEA,SAASkC,oBAAoB,CAAEf,QAAQ,EAAEgB,KAAK,EAAE;EAC9CA,KAAK,GAAG;IACNf,gBAAgB,EAAED,QAAQ;IAC1B,GAAGgB;EACL,CAAC;EAED,OAAO,IAAIC,KAAK,CAACjB,QAAQ,EAAE;IACzBkB,GAAG,CAAEC,MAAM,EAAEC,CAAC,EAAE;MACd,OAAOA,CAAC,IAAIJ,KAAK,GAAGA,KAAK,CAACI,CAAC,CAAC,GAAGD,MAAM,CAACC,CAAC,CAAC;IAC1C,CAAC;IACDC,GAAG,CAAEF,MAAM,EAAEC,CAAC,EAAEjD,KAAK,EAAE;MACrBrC,MAAM,CAAC,EAAEsF,CAAC,IAAIJ,KAAK,CAAC,CAAC;MACrBG,MAAM,CAACC,CAAC,CAAC,GAAGjD,KAAK;MACjB,OAAO,IAAI;IACb;EACF,CAAC,CAAC;AACJ;;AAEA;AACA,SAAS+B,cAAc,CAAEF,QAAQ,EAAE1C,IAAI,EAAE;EACvC;EACA;EACA,IAAIA,IAAI,KAAK,OAAO,EAAE;IACpB;IACA;IACA;;IAEA;IACA,OAAOyD,oBAAoB,CAACf,QAAQ,EAAE;MACpC1C,IAAI,EAAE,OAAO;MACbd,WAAW,EAAEwD,QAAQ,CAACxD;IACxB,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIc,IAAI,KAAK,MAAM,EAAE;IAC1B;IACA;IACA;IACA;;IAEA;IACA,OAAOyD,oBAAoB,CAACf,QAAQ,EAAE;MACpC1C,IAAI,EAAE,MAAM;MACZd,WAAW,EAAEwD,QAAQ,CAACxD;IACxB,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIc,IAAI,KAAK,QAAQ,EAAE;IAC5B;IACA;IACA;;IAEA,OAAOyD,oBAAoB,CAACf,QAAQ,EAAE;MACpC1C,IAAI,EAAE,QAAQ;MACd0B,OAAO,EAAElB,MAAM,CAACwD,MAAM,CAAC,EAAE,CAAC;MAC1B7D,MAAM,EAAE,CAAC;MACTyB,UAAU,EAAE,EAAE;MACd9B,IAAI,EAAE;IACR,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIE,IAAI,KAAK,gBAAgB,EAAE;IACpC;IACA;IACA;;IAEA,OAAOyD,oBAAoB,CAACf,QAAQ,EAAE;MACpC1C,IAAI,EAAE,gBAAgB;MACtBG,MAAM,EAAE,CAAC;MACTyB,UAAU,EAAE,EAAE;MACd1C,WAAW,EAAE,EAAE;MACfY,IAAI,EAAE;IACR,CAAC,CAAC;EACJ,CAAC,MAAM;IACLtB,MAAM,CAAC,KAAK,CAAC;EACf;AACF;;AAEA;AACA,SAASyF,2BAA2B,CAAEC,WAAW,EAAE;EACjD;EACA1F,MAAM,CAAChB,WAAW,CAAC0G,WAAW,CAAC,CAAC;;EAEhC;EACA;EACA,OAAOzG,SAAS,CAACyG,WAAW,CAAC,GACzBjF,gBAAgB,CAAC,IAAIlB,YAAY,CAAC,4BAA4B,EAAE,YAAY,CAAC,CAAC,GAC9EkB,gBAAgB,CAACiF,WAAW,CAACC,UAAU,CAACC,UAAU,CAAChB,MAAM,CAAC;AAChE;;AAEA;AACA,SAASrD,kBAAkB,CAAE2C,QAAQ,EAAErD,IAAI,EAAES,IAAI,EAAE;EACjD;EACA;EACA,IAAIT,IAAI,CAACc,MAAM,KAAK,IAAI,KAAKd,IAAI,CAACc,MAAM,GAAG,GAAG,IAAId,IAAI,CAACc,MAAM,GAAG,GAAG,CAAC,EAAE;IACpE,MAAM,IAAIS,UAAU,CAAC,+DAA+D,CAAC;EACvF;;EAEA;EACA;EACA,IAAI,YAAY,IAAIvB,IAAI,IAAIA,IAAI,CAACuC,UAAU,IAAI,IAAI,EAAE;IACnD;IACA;IACA,IAAI,CAACrE,mBAAmB,CAACgG,MAAM,CAAClE,IAAI,CAACuC,UAAU,CAAC,CAAC,EAAE;MACjD,MAAM,IAAIpC,SAAS,CAAC,oBAAoB,CAAC;IAC3C;EACF;;EAEA;EACA,IAAI,QAAQ,IAAIH,IAAI,IAAIA,IAAI,CAACc,MAAM,IAAI,IAAI,EAAE;IAC3CuC,QAAQ,CAAC1E,MAAM,CAAC,CAACmC,MAAM,GAAGd,IAAI,CAACc,MAAM;EACvC;;EAEA;EACA,IAAI,YAAY,IAAId,IAAI,IAAIA,IAAI,CAACuC,UAAU,IAAI,IAAI,EAAE;IACnDc,QAAQ,CAAC1E,MAAM,CAAC,CAAC4D,UAAU,GAAGvC,IAAI,CAACuC,UAAU;EAC/C;;EAEA;EACA,IAAI,SAAS,IAAIvC,IAAI,IAAIA,IAAI,CAACwC,OAAO,IAAI,IAAI,EAAE;IAC7C9E,IAAI,CAAC2F,QAAQ,CAAC1E,MAAM,CAAC,CAACkB,WAAW,EAAEG,IAAI,CAACwC,OAAO,CAAC;EAClD;;EAEA;EACA,IAAI/B,IAAI,EAAE;IACR;IACA,IAAIhC,cAAc,CAAC6C,QAAQ,CAAC+B,QAAQ,CAACvC,MAAM,CAAC,EAAE;MAC5C/B,MAAM,CAAC6D,MAAM,CAACC,SAAS,CAAC;QACtBC,MAAM,EAAE,sBAAsB;QAC9BC,OAAO,EAAE;MACX,CAAC,CAAC;IACJ;;IAEA;IACAM,QAAQ,CAAC1E,MAAM,CAAC,CAAC8B,IAAI,GAAGA,IAAI,CAACA,IAAI;;IAEjC;IACA;IACA,IAAIA,IAAI,CAACE,IAAI,IAAI,IAAI,IAAI,CAAC0C,QAAQ,CAAC1E,MAAM,CAAC,CAACkB,WAAW,CAACmF,GAAG,CAAC,cAAc,CAAC,EAAE;MAC1E3B,QAAQ,CAAC1E,MAAM,CAAC,CAACkB,WAAW,CAAC6B,MAAM,CAAC,cAAc,EAAEjB,IAAI,CAACE,IAAI,CAAC;IAChE;EACF;AACF;AAEA5B,MAAM,CAACqB,UAAU,CAACf,cAAc,GAAGN,MAAM,CAACkG,kBAAkB,CAC1D5F,cAAc,CACf;AAEDN,MAAM,CAACqB,UAAU,CAACpB,QAAQ,GAAGD,MAAM,CAACkG,kBAAkB,CACpDjG,QAAQ,CACT;AAEDD,MAAM,CAACqB,UAAU,CAAC8E,eAAe,GAAGnG,MAAM,CAACkG,kBAAkB,CAC3DC,eAAe,CAChB;;AAED;AACAnG,MAAM,CAACqB,UAAU,CAAC+E,sBAAsB,GAAG,UAAUC,CAAC,EAAE;EACtD,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;IACzB,OAAOrG,MAAM,CAACqB,UAAU,CAACW,SAAS,CAACqE,CAAC,CAAC;EACvC;EAEA,IAAI/G,UAAU,CAAC+G,CAAC,CAAC,EAAE;IACjB,OAAOrG,MAAM,CAACqB,UAAU,CAACiF,IAAI,CAACD,CAAC,EAAE;MAAEE,MAAM,EAAE;IAAM,CAAC,CAAC;EACrD;EAEA,IACElG,KAAK,CAACmG,gBAAgB,CAACH,CAAC,CAAC,IACzBhG,KAAK,CAACoG,YAAY,CAACJ,CAAC,CAAC,IACrBhG,KAAK,CAACqG,UAAU,CAACL,CAAC,CAAC,EACnB;IACA,OAAOrG,MAAM,CAACqB,UAAU,CAACsF,YAAY,CAACN,CAAC,CAAC;EAC1C;EAEA,IAAIrH,IAAI,CAAC4H,cAAc,CAACP,CAAC,CAAC,EAAE;IAC1B,OAAOrG,MAAM,CAACqB,UAAU,CAACpB,QAAQ,CAACoG,CAAC,EAAE;MAAEE,MAAM,EAAE;IAAM,CAAC,CAAC;EACzD;EAEA,IAAIF,CAAC,YAAYF,eAAe,EAAE;IAChC,OAAOnG,MAAM,CAACqB,UAAU,CAAC8E,eAAe,CAACE,CAAC,CAAC;EAC7C;EAEA,OAAOrG,MAAM,CAACqB,UAAU,CAACwF,SAAS,CAACR,CAAC,CAAC;AACvC,CAAC;;AAED;AACArG,MAAM,CAACqB,UAAU,CAACwB,QAAQ,GAAG,UAAUwD,CAAC,EAAE;EACxC,IAAIA,CAAC,YAAY/F,cAAc,EAAE;IAC/B,OAAON,MAAM,CAACqB,UAAU,CAACf,cAAc,CAAC+F,CAAC,CAAC;EAC5C;;EAEA;EACA;EACA,IAAIA,CAAC,GAAGpD,MAAM,CAAC6D,aAAa,CAAC,EAAE;IAC7B,OAAOT,CAAC;EACV;EAEA,OAAOrG,MAAM,CAACqB,UAAU,CAAC+E,sBAAsB,CAACC,CAAC,CAAC;AACpD,CAAC;AAEDrG,MAAM,CAACqB,UAAU,CAACC,YAAY,GAAGtB,MAAM,CAAC+G,mBAAmB,CAAC,CAC1D;EACEC,GAAG,EAAE,QAAQ;EACbC,SAAS,EAAEjH,MAAM,CAACqB,UAAU,CAAC,gBAAgB,CAAC;EAC9C6F,YAAY,EAAE;AAChB,CAAC,EACD;EACEF,GAAG,EAAE,YAAY;EACjBC,SAAS,EAAEjH,MAAM,CAACqB,UAAU,CAAC8F,UAAU;EACvCD,YAAY,EAAE;AAChB,CAAC,EACD;EACEF,GAAG,EAAE,SAAS;EACdC,SAAS,EAAEjH,MAAM,CAACqB,UAAU,CAAC+F;AAC/B,CAAC,CACF,CAAC;AAEFC,MAAM,CAACC,OAAO,GAAG;EACfzG,gBAAgB;EAChBiC,YAAY;EACZ+C,2BAA2B;EAC3BrB,cAAc;EACdhE;AACF,CAAC"},"metadata":{},"sourceType":"script"}